[{"content":"Karabiner 配置项 Fn + JKLI(SDFE) = left, down, right, up, Fn + space = backspace, Fn + n = 4: config.json\n","date":"2025-01-25T11:57:31+08:00","permalink":"https://3000ye.com/p/karabiner/","title":"Karabiner"},{"content":"Git Commit Message 规范 Git Commit Message 虽然可以随意描述，但使用没有意义的描述对于后续 review 代码以及理解代码用途等方面都会造成巨大的影响。因此 Commit Message 具有意义是最基本的要求，此外，你还应该遵守一定的格式规范，这样能够让大家更快更清晰地了解该 Commit 的详情。这里我主要介绍下常规的 Git Commit 规范和 Gitmoji 规范，最后介绍下我常用的相关配置。\nCommit Message 最基本的组成为：header、body、footer：\n1 2 3 4 5 \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;body\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;footer\u0026gt; 根据 conventional-commit-types, type 的可选值一般来说是有下面几种\nfeat: 添加新功能 fix: 修复 bug docs: 仅对文档进行修改 style: 对代码语义无影响的格式修改（如去除无用空格、格式化等等修改） refactor: 代码重构（既不是新增功能，也不是修改 bug 的代码变动） perf: 提高性能的代码修改 test: 测试用例添加及修改 build: 影响构建系统或外部依赖关系的更改 ci: 更改 CI 配置文件和脚本 chore: 其它不涉及源码以及测试的修改 一般情况，commit 只会包含 header 部分。\nGitmoji 规范允许你在 Commit Message 中使用 Emoji ，简单的说，你可以用生动形象的 Emoji 来表示该次 Commit 的 type，Gitmoji 推荐的 header 格式是：\n1 \u0026lt;gitmoji\u0026gt;\u0026lt;type\u0026gt;: \u0026lt;subject\u0026gt; 常见的 moji 如下所示：\nview code mean translate 🎨 :art: Improve structure / format of the code. 改良结构和代码格式 ⚡️ :zap: Improve performance. 优化性能 🔥 :fire: Remove code or files. 移除代码或文件 🐛 :bug: Fix a bug. 修复 bug 🚑 :ambulance: Critical hotfix. 紧急的热修复 ✨ :sparkles: Introduce new features. 引入新功能 📝 :memo: Add or update documentation. 添加或更新文档 🚀 :rocket: Deploy stuff. 部署 💄 :lipstick: Add or update the UI and style files. 添加或更新 UI 和样式文件 🎉 :tada: Begin a project. 开始一个全新的项目～ ✅ :white_check_mark: Add or update tests. 添加或更新测试用例 🔒 :lock: Fix security issues. 修复安全问题 🔖 :bookmark: Release / Version tags. 发版 / 版本标签 🚨 :rotating_light: Fix compiler / linter warnings. 修复编译器或者 linter 的 warning 🚧 :construction: Work in progress. 工作在进行中 💚 :green_heart: Fix CI Build. 修复 CI 构建问题 ⬇️ :arrow_down: Downgrade dependencies. 降级依赖库 ⬆️ :arrow_up: Upgrade dependencies. 升级依赖库 📌 :pushpin: Pin dependencies to specific versions. 将依赖库固定到特定版本 👷 :construction_worker: Add or update CI build system. 添加或更新 CI 构建系统 📈 :chart_with_upwards_trend: Add or update analytics or track code. 添加或更新分析或跟踪代码 ♻️ :recycle: Refactor code. 重构代码 ➕ :heavy_plus_sign: Add a dependency. 添加一个依赖项 ➖ :heavy_minus_sign: Remove a dependency. 删除一个依赖项 🔧 :wrench: Add or update configuration files. 添加或改变配置文件 🔨 :hammer: Add or update development scripts. 添加或更新构开发脚本 🌐 :globe_with_meridians: Internationalization and localization. 国际化和本地化（i18n） ✏️ :pencil2: Fix typos. 修复拼写错误 💩 :poop: Write bad code that needs to be improved. 当前代码尚需优化 ⏪ :rewind: Revert changes. 撤销之前的修改 🔀 :twisted_rightwards_arrows: Merge branches. 合并分支 📦 :package: Add or update compiled files or packages. 添加或更新编译的文件或包 👽 :alien: Update code due to external API changes. 由于外部 API 更改而更新代码 🚚 :truck: Move or rename resources (e.g.: files, paths, routes). 移动或重命名资源（诸如：文件、路径、路由） 📄 :page_facing_up: Add or update license. 添加或更新 LICENSE 💥 :boom: Introduce breaking changes. 引入不兼容的变动 🍱 :bento: Add or update assets. 添加或更新静态资源 ♿️ :wheelchair: Improve accessibility. 提高可访问性 💡 :bulb: Add or update comments in source code. 在源代码中添加或更新注释 🍻 :beers: Write code drunkenly. 醉醺醺地编写代码 💬 :speech_balloon: Add or update text and literals. 添加或更新用于文本、对话框等文本字面量相关的更改 🗃 :card_file_box: Perform database related changes. 执行与数据库相关的更改 🔊 :loud_sound: Add or update logs. 添加或更新日志 🔇 :mute: Remove logs. 删除日志 👥 :busts_in_silhouette: Add or update contributor(s). 添加或更新贡献者 🚸 :children_crossing: Improve user experience / usability. 改善用户体验/可用性 🏗 :building_construction: Make architectural changes. 改变架构 📱 :iphone: Work on responsive design. 进行响应式设计 🤡 :clown_face: Mock things. 添加或更改 mock 🥚 :egg: Add or update an easter egg. 添加或更新彩蛋内容 🙈 :see_no_evil: Add or update a .gitignore file. 添加或更新 .gitignore 文件 📸 :camera_flash: Add or updatesnapshots. 添加或更新快照 ⚗️ :alembic: Perform experiments. 实验性内容 🔍 :mag: Improve SEO. 提高 SEO 🏷 :label: Add or update types. 添加或更新类型声明 🌱 :seedling: Add or update seed files. 添加或更新种子文件 🚩 :triangular_flag_on_post: Add, update, or remove feature flags. 添加、更新或删除功能标志 🥅 :goal_net: Catch errors. 捕获错误 💫 :dizzy: Add or update animations and transitions. 添加或更新动画和过渡 🗑 :wastebasket: Deprecate code that needs to be cleaned up. 清理冗余代码 🛂 :passport_control: Work on code related to authorization, roles and permissions. 处理与授权、账户和权限相关的代码 ｜ 🩹 :adhesive_bandage: Simple fix for a non-critical issue. 简单修复一个非关键问题 🧐 :monocle_face: Data exploration/inspection. 数据探索/检查 ⚰️ :coffin: Remove dead code. 清除无效代码 🧪 :test_tube: Add a failing test. 添加一个运行失败的测试用例（TDD 第一步） 👔 :necktie: Add or update business logic. 添加或更新业务逻辑 🩺 :stethoscope: Add or update healthcheck. 添加或更新健康检查 🧱 :bricks: Infrastructure related changes. 基础设施相关改动 🧑‍💻 :technologist: Improve developer experience. 提升开发体验 🔐 :closed_lock_with_key: Add or update secrets. 添加或更新加密内容 💸 :money_with_wings: Add sponsorships or money related infrastructure. 添加赞助商或者资金支持相关内容 🧵 :thread: Add or update code related to multithreading or concurrency. 添加或更新多线程或与并发相关的代码","date":"2025-01-19T23:46:43+08:00","permalink":"https://3000ye.com/p/git-moji/","title":"Git moji"},{"content":"Rust 安装与配置 安装 安装 Rust 官网安装：一路回车就行了\n1 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh 换源安装（中科大源）：\n1 2 3 4 5 6 curl --proto \u0026#39;https\u0026#39; --tlsv1.2 https://mirrors.ustc.edu.cn/misc/rustup-install.sh -sSf \u0026gt; rust.sh \u0026amp;\u0026amp; chmod +x rust.sh export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup sudo bash rust.sh 查看 Rust 版本 1 2 rustc -V cargo -V 配置 包管理器换源 可以直接新建 ~/.cargo/config.toml 文件，写入：\n1 2 3 4 5 [source.crates-io] replace-with = \u0026#39;ustc\u0026#39; [source.ustc] registry = \u0026#34;sparse+https://mirrors.ustc.edu.cn/crates.io-index/\u0026#34; 或者安装 crm 镜像源管理器：crm\n1 2 3 cargo install crm crm best ","date":"2025-01-06T20:50:10+08:00","image":"https://3000ye.com/p/rust-configure/assets/rust_hu_80012820a56df02c.png","permalink":"https://3000ye.com/p/rust-configure/","title":"Rust Configure"},{"content":"Wakatime 数据同步到飞书多维表格 获取 Wakatime API KEY 访问 api-key 获取 API-KEY，相关接口可以查看文档：developers。\n飞书创建多维表格 按照想要的数据创建对应的多维表格：\n飞书构建仪表盘 按照想要的效果构建仪表盘：\nPython 脚本调通 需要注意 Wakatime 数据的获取方式，本文采用 API-KEY 的方式获取：\n1 2 3 4 5 6 7 8 WAKATIME_API_KEY = \u0026#34;xxxxxxxxxxxxxxxxxx\u0026#34; HEADERS = { \u0026#34;Authorization\u0026#34;: \u0026#34;Basic \u0026#34; + base64.b64encode(WAKATIME_API_KEY.encode(\u0026#34;utf-8\u0026#34;)).decode(\u0026#34;utf-8\u0026#34;) + \u0026#34;=\u0026#34;, } BASE_URL = \u0026#34;https://wakatime.com/api/v1/users/current/summaries\u0026#34; url = f\u0026#34;{BASE_URL}?start=2024-09-10\u0026amp;end=2024-09-10\u0026#34; resp = requests.get(url, headers=HEADERS) 服务器部署 定时器和服务器编写 分别编写 timer 和 service 脚本：\n1 2 3 4 5 6 7 8 9 10 [Unit] Description=Wakatime to Feishu [Timer] # OnCalendar设置定时规则，这里是每天10点 OnCalendar=*-*-* 10:00:00 Unit=wakatime.service [Install] WantedBy=timers.target 1 2 3 4 5 6 7 8 [Unit] Description=Wakatime to Feishu [Service] Type=simple User=castor # 建议使用 shell 脚本 ExecStart=/home/castor/Wakatime2Feishu/client.sh 建议使用 client.sh 来启动 main.py 脚本，可以避免 Python 环境的混乱：\n1 2 3 4 #!/bin/bash cd /home/castor/Wakatime2Feishu python3 main.py 启用定时任务 1 2 3 4 5 6 7 8 9 10 11 # 复制定时器 sudo cp wakatime.timer /etc/systemd/system/ sudo cp wakatime.service /etc/systemd/system/ # 重载定时任务，启用并开始定时任务 sudo systemctl daemon-reload sudo systemctl enable wakatime.timer sudo systemctl start wakatime.timer # 查看定时任务列表 sudo systemctl list-timers ","date":"2024-09-14T01:25:39+08:00","image":"https://3000ye.com/p/wakatime-robot/assets/wakatime_hu_9404a7af0e0e1c57.png","permalink":"https://3000ye.com/p/wakatime-robot/","title":"Wakatime Robot"},{"content":"karabiner 官网链接：https://karabiner-elements.pqrs.org\nMacOs 修改键盘布局软件，可以自定义任意按键。通过这个软件，可以将 MacBook 的键盘修改为 HHKB 配列。下面是配置备份：\n快捷设置 将 Control，Command 和 Fn 替换：\n脚本配置 设置快捷键：Fn + JKLI = left, down, right, up：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 { \u0026#34;description\u0026#34;: \u0026#34;Fn + JKLI = left, down, right, up\u0026#34;, \u0026#34;manipulators\u0026#34;: [ { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;j\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;mandatory\u0026#34;: [\u0026#34;fn\u0026#34;], \u0026#34;optional\u0026#34;: [\u0026#34;caps_lock\u0026#34;, \u0026#34;option\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;control\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;left_arrow\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; }, { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;k\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;mandatory\u0026#34;: [\u0026#34;fn\u0026#34;], \u0026#34;optional\u0026#34;: [\u0026#34;caps_lock\u0026#34;, \u0026#34;option\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;control\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;down_arrow\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; }, { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;l\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;mandatory\u0026#34;: [\u0026#34;fn\u0026#34;], \u0026#34;optional\u0026#34;: [\u0026#34;caps_lock\u0026#34;, \u0026#34;option\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;control\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;right_arrow\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; }, { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;i\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;mandatory\u0026#34;: [\u0026#34;fn\u0026#34;], \u0026#34;optional\u0026#34;: [\u0026#34;caps_lock\u0026#34;, \u0026#34;option\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;control\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;up_arrow\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; }, { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;o\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;mandatory\u0026#34;: [\u0026#34;fn\u0026#34;], \u0026#34;optional\u0026#34;: [\u0026#34;caps_lock\u0026#34;, \u0026#34;option\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;control\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;end\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; }, { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;u\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;mandatory\u0026#34;: [\u0026#34;fn\u0026#34;], \u0026#34;optional\u0026#34;: [\u0026#34;caps_lock\u0026#34;, \u0026#34;option\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;control\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;home\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; }, { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;spacebar\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;mandatory\u0026#34;: [\u0026#34;fn\u0026#34;], \u0026#34;optional\u0026#34;: [\u0026#34;caps_lock\u0026#34;, \u0026#34;option\u0026#34;, \u0026#34;shift\u0026#34;, \u0026#34;control\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;delete_or_backspace\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; } ] } Stats Github 仓库：https://github.com/exelban/stats\n在 MacOs 的 Bar 上显示设备信息：CPU、GPU、WLAN 等，配置备份：/assets/Stats.plist：\nLoop Github 仓库：https://github.com/MrKai77/Loop\n在 MacOs 上快捷移动应用窗口、左右上下贴靠等，配置备份：/assets/loop.json：\n","date":"2024-08-19T13:40:11+08:00","permalink":"https://3000ye.com/p/macos-applications/","title":"MacOs Applications"},{"content":"MaxOS 安装 PyTorch 安装 Conda 根据官方文档安装 MiniConda：https://docs.anaconda.com/miniconda/\n1 2 3 4 5 6 mkdir -p ~/miniconda3 curl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh -o ~/miniconda3/miniconda.sh bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3 rm -rf ~/miniconda3/miniconda.sh ~/miniconda3/bin/conda init zsh 查看 Conda 版本：\n1 conda --version 新建 Conda 环境 新建 Conda 环境，Python 版本最好高于 3.8：\n1 2 3 conda create -n pytorch_learn python = 3.10 conda activate pytorch_learn 安装 PyTorch 根据 PyTorch 官网的提示安装：https://pytorch.org\n1 pip3 install torch torchvision torchaudio 重装 numpy（非必须），有可能 PyTorch 自带的 numpy 版本过低，可以手动重装：\n1 2 pip3 uninstall numpy pip3 install numpy 配置 Jupyter GPU Kernel 为了使用 MaxOS M 芯片的 GPU，需要安装一个新的 Jupyter 内核：\n1 2 3 4 conda activate pytorch_learn //注意替换成自己的虚拟环境名 conda install ipykernel //安装ipykernel sudo python -m ipykernel install --name pytorch_learn //在ipykernel中安装当前环境 conda deactivate 启动 Jupyter 后切换 内核：\n测试 PyTorch 1 2 3 4 5 6 import torch print(torch.backends.mps.is_available()) print(torch.backends.mps.is_built()) device = torch.device(\u0026#34;mps\u0026#34; if torch.backends.mps.is_available() else \u0026#34;cpu\u0026#34;) ","date":"2024-08-15T16:25:46+08:00","image":"https://3000ye.com/p/install-pytorch-on-maxos/assets/pytorch_hu_2b9abcc0a54df0b7.png","permalink":"https://3000ye.com/p/install-pytorch-on-maxos/","title":"Install PyTorch on MaxOS"},{"content":"一名程序员此生喝过的所有啤酒 力波啤酒-红 啤酒信息 品名：力波全麦芽啤酒·红力波 原料：水、麦芽、啤酒花、酵母 酒精度：4.1% vol 原麦汁浓度：11.0$^\\circ$ P 条码：6974659850009 价格：10 元（路边超市购买） 品鉴结果 外观：酒体金黄，泡沫丰富绵密 香气：麦芽香，酵母香，甜中带酸 味道：甜、酸平衡，香气浓郁 口感：顺滑，柔中带强，收口清爽，不涩口 总体评价：8 分。上海本地啤酒，几乎所有路边超市都有卖，浓郁清爽的口感配得上它的价格，但算不上惊艳。 图片展示 奥乐齐-全麦拉格啤酒 啤酒信息 品名：德式全麦芽拉格鲜啤酒（奥乐齐） 原料：水、大麦芽、小麦芽、酵母、啤酒花 酒精度：4.8% vol 原麦汁浓度：12$^\\circ$ P 条码：6959408002298 价格：7.9 元（奥乐齐购买） 品鉴信息 外观：酒体金黄，泡沫丰富绵密 香气：麦芽香，甜香 味道：麦芽风味浓郁 口感：酒体过于厚重，不够清冽，收口发涩 总体评价：6 分。奥乐齐自家推出的啤酒，虽然价格便宜但是口感较差（冰箱放过也一样），不加冰块完全没法喝。 图片展示 BERGKONIG-烈性啤酒 啤酒信息 品名：BERGKONIG-烈性啤酒（奥地利） 原料：水、大麦芽、啤酒花、二氧化碳酒花浸膏 酒精度：7.2% vol 原麦汁浓度：16.5$\\circ$ P 条码：4061464598973 价格：7.1 元（奥乐齐购买） 品鉴信息 外观：酒体呈琥珀色，泡沫丰富但消的较快（可能是日期不够新鲜） 香气：麦芽香，酒香 味道：打开就喝会略微发苦，回温后甜度涌现，酒香和甜香四溢 口感：酒体干净，入喉顺畅，酒液不会附着在口腔中，入喉后舌头生津 总体评价：8.5 分。在低价位中少见的高麦度啤酒，酒体干净口感清冽，适当回温会激发更多甜香，可以当做小罗斯福来做口粮酒。 图片展示 一番榨-樱花限定版 啤酒信息 品名：一番榨啤酒-樱花限定版 原料：水、麦芽、啤酒花 酒精度：4.5% vol 原麦汁浓度：11.0$\\circ$ P 条码：6921014065332 价格：10 元（罗森购买） 品鉴结果 外观：酒体金黄色，泡沫丰富 香气：麦芽香 味道：麦芽风味浓郁 口感：非常好入喉，感觉酒液在嘴里一泄而过，口感清冽 总体评价：7 分。虽然香气和风味比之其他啤酒稍差，但是其入喉顺畅的特点太过突出。 图片展示 燕京啤酒-原浆白啤 啤酒信息 品名：燕京啤酒-原浆白啤 原料：水、麦芽、啤酒花、酵母 酒精度：4.1% vol 原麦汁浓度：12$\\circ$ P 条码：6903102105267 价格：9 元（罗森购买） 品鉴信息 外观：酒体金黄，泡沫丰富 香气：麦芽香 味道：麦芽风味浓郁 口感：入喉稍有阻塞感，收口偏涩 总体评价：6.8 分。总体表现一般，只能说过得去。 图片展示 ","date":"2024-07-31T23:22:31+08:00","image":"https://3000ye.com/p/awesome-beer/assets/beer_hu_66fbd67eadea185f.webp","permalink":"https://3000ye.com/p/awesome-beer/","title":"Awesome Beer"},{"content":"Swift 教程 Swift 基础 常量和变量 声明常量和变量 在 Swift 中，常量使用 let 进行声明，变量使用 var 进行声明：\n1 2 let MAX = 10; var intVar = 20; 类型注解 在 Swift 中，程序会根据声明的值来自动分析标识符的类型，同时也提供了显示指定类型的方法：\n1 2 3 4 5 6 7 8 9 var intVar:int = 10; var doubleVar:double = 10; print(\u0026#34;intVar = \\(intVar)\u0026#34;); print(\u0026#34;doubleVar = \\(doubleVar)\u0026#34;) // --------------- 输出 -------------------- // intVar = 10 // doubleVar = 10.0 需要注意的是，若只不在声明时定义标识符的值，则必须指定类型：\n1 2 3 4 5 6 var testVar: String; testVar = \u0026#34;test var\u0026#34;; print(testVar) // --------------- 输出 -------------------- // test var 整数 Swift 提供了8、16、32和64位的有符号和无符号整数类型。\n整数范围 可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值：\n1 2 let minValue = UInt8.min // minValue 为 0，是 UInt8 类型 let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型 Int 与 UInt Swift 提供了一个特殊的整数类型 Int，长度与当前平台的原生字长相同：\n在 32 位平台上，Int 和 Int32 长度相同。 在 64 位平台上，Int 和 Int64 长度相同。 同样的，UInt 的长度也与当前平台的原生字长相同。\n浮点数 Swift 提供两种有符号浮点数类型：\nDouble 表示 64 位浮点数。 Float 表示 32 位浮点数。 数值型字面量 整数字面量可以被写作：\n一个 十进制 数：没有前缀 一个 二进制 数：前缀为 0b 一个 八进制 数：前缀是 0o 一个 十六进制 数：前缀是 0x 若想要用指数 exp 表示，则可在浮点数字面量后面添加大写或小写的 e 来指定。\n1 2 3 4 let decInt = 10 let binInt = 0b1011 let expDouble = 1.25e2 类型别名 可以使用以下方法对指定类型定义一个别名：\n1 typealias newType = Int64 布尔值 在 Swift 中布尔值强制使用 true 和 false 来表示，0 和 1 不能作为布尔值进行判断。\n元组 在 Swift 中的元组可以包含任意多个值，且这些值可以是任意类型：\n1 2 3 4 5 6 7 // 构造元组 let tuple = (10, \u0026#34;hello\u0026#34;); // 拆分元组 let (x, y) = tuple; let (x, _) = tuple; // 下标访问 let z = tuple.0; 和其他语言不同的是，Swift 的元组支持为元素命名，以实现便携的访问：\n1 2 3 let nameTuple = (code: 11, des: \u0026#34;hello\u0026#34;); print(nameTuple.code) 可选类型 可选类型（options）用于处理值可能缺失的情况，其表示两种可能：\n有值，可以通过强制解析来访问这个值 没有值，等于 nil 例如，在类型转换时，不一定能成功转换：\n1 2 let x = \u0026#34;123\u0026#34;, y = \u0026#34;hello\u0026#34;; print(Int(x), Int(y)); 其中 Int(x) 有值，可以强制解析；而 Int(y) 没有值，等于 nil。\nnil 对于没有值的变量，可以直接对其赋值 nil 来表示它没有值：\n1 2 var x:String? = \u0026#34;hello\u0026#34;; x = nil; 强制解析 对于可选类型的变量，如果确定其有值，则在其后面加一个 ! 强制解析来访问其值：\n1 2 3 4 var x = \u0026#34;123\u0026#34;; var y = Int(x); print(y!); ","date":"2024-04-25T00:28:05+08:00","image":"https://3000ye.com/p/swift-tutorial/assets/swift_hu_d54cc86372339a38.png","permalink":"https://3000ye.com/p/swift-tutorial/","title":"Swift Tutorial"},{"content":"函数的应用 函数模板 函数模板和模板函数 当我们在编写函数时，若两个函数如下所示，只存在变量类型的差异：\n1 2 3 int intSolve(int a, int b) { return a \u0026gt; b ? a : b; } double doubleSolve(double a, double b) { return a \u0026gt; b ? a : b; } 此时我们当然可以直接复制其中一个函数，然后修改其中的类型来实现我们的需求，但是这样会增加代码的冗余和出错的可能性。\n我们可以发现，如果不管变量是任何类型，函数都可以正常运行就好了。 在 CPP 中可以使用 泛型 （genericity）函数来实现，基于泛型实现的函数称为 泛型函数 ：\n1 2 template \u0026lt;class T\u0026gt; T solve(T a, T b) { return a \u0026gt; b ? a : b; } 其中前缀 template \u0026lt;class T\u0026gt; 表明接下来声明的是 函数模板（function template），而不是普通函数，接收的 类型 要赋给函数的形参 T（T 可以取任意名称）。\n调用时直接使用函数模板即可：\n1 2 long a = 2, b = 3; cout \u0026lt;\u0026lt; solve(a, b) \u0026lt;\u0026lt; endl; 在使用函数模板时，编译器会自动查找传入参数的类型，并将函数模板的 T 修改为对应类型，这样创建的函数实体称为 模板函数（template function）。\n在创建模板函数时，如果传入的参数类型错误，则会引发报错：\n1 2 3 4 5 6 long a = 2, b = 3; short c = 4; cout \u0026lt;\u0026lt; solve(a, c) \u0026lt;\u0026lt; endl; error generated: candidate template ignored: deduced conflicting types for parameter \u0026#39;T\u0026#39; (\u0026#39;long\u0026#39; vs. \u0026#39;short\u0026#39;) 显式实例化 在上文中我们提到，在创建模板函数时如果传入的参数类型错误则会引发报错，那么有没有方法可以解决这种报错呢？\nCPP 提供了 显式实例化 的方法来创建模板函数：\n1 2 3 long a = 2, b = 3; short c = 4; cout \u0026lt;\u0026lt; solve\u0026lt;long\u0026gt;(a, c) \u0026lt;\u0026lt; endl; 使用显式实例化的方式创建模板函数，函数会使用指定的类型进行实例化。\n显式特例化 虽然函数模板可以对任意类型的变量起作用，但是对于例如 string 类型的变量：\n1 cout \u0026lt;\u0026lt; solve(\u0026#34;ABC\u0026#34;, \u0026#34;EFG\u0026#34;) \u0026lt;\u0026lt; endl; 这样实例化的模板函数在功能上来说是没有意义的，因为实际比较的是两个字面量的地址而非 string 的实际大小。因此，对于这种情况，我们需要特例化一个模板函数：\n1 2 3 4 5 6 7 8 template \u0026lt;\u0026gt; const char* solve\u0026lt;const char*\u0026gt; (const char* a, const char* b) { return strcmp(a, b) ? a : b; } int main() { cout \u0026lt;\u0026lt; solve\u0026lt;const char*\u0026gt;(\u0026#34;EFG\u0026#34;, \u0026#34;ABC\u0026#34;) \u0026lt;\u0026lt; endl; return 0; } 显式特例化的定义一般为：\n1 template \u0026lt;\u0026gt; 返回值类型 func\u0026lt;T\u0026gt; (入参) { 函数体 } 大规模程序的开发 分离式编译和链接 在大型项目开发中，我们常常会使用多个源文件来管理和开发不同模块，如下面所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // test1.cpp #include \u0026#34;iostream\u0026#34; using namespace std; const int MAX = 10; // 定义常量 int solve(int a, int b); // 声明函数 int main() { int a = 2, b = 3; cout \u0026lt;\u0026lt; solve(a, b) \u0026lt;\u0026lt; endl; return 0; } // --------------------------------------- // test2.cpp extern int MAX; // 声明变量的使用 // 定义函数 int solve(int a, int b) { return a \u0026gt; b ? MAX : a - b; } 在编译时分别对不同源文件进行编译，然后链接在一起：\n1 2 3 clang++ -c test1.cpp -o test1.o clang++ -c test2.cpp -o test2.o clang++ test1.o test2.o -o test 在 CPP 程序中，需遵循 单一定义规则（One Definition Rule, ODR）：对象和函数只能定义一次。\n因此，当我们在 A.cpp 中定义了某个对象或函数，想在 B.cpp 中使用时，就必须使用 extern 关键字进行声明。\n同时，如果我们在 A.cpp 中定义了某个对象或函数，不想让其他文件使用该对象或函数，可以使用 static 关键字进行声明和定义：\n1 2 3 4 5 6 7 // test1.cpp static const int MIN = 10; // --------------------------------------- // test2.cpp extern const int MIN; // clang++: error: linker command failed with exit code 1 如上所示，使用 static 声明和定义的对象和函数只能在其源文件中使用的情况，称为 内部链接（internal linkage）。此外，对于该程序中没有使用的以下函数或对象，即时没有 static，也会被自动赋予内部链接：\n内联函数 const 定义的常量对象 头文件 当源文件数量增加时，为了方便管理和维护，我们使用头文件来集中管理具有外部链接的变量和函数等的声明。\n1 2 3 // test.hpp const int MAX = 10; int solve(int a, int b); 注意：使用自定义的头文件时，要用 \u0026quot;...\u0026quot; 而不是 \u0026lt;...\u0026gt;，其区别在于：\n#include \u0026lt;...\u0026gt; 会优先查找存储编译器提供标准库的地方。 #include \u0026quot;...\u0026quot; 会优先查找源文件所在目录。 命名空间 命名空间的定义 作用域依赖于源文件中的声明的物理位置，名称的通用范围依赖于源文件这样的物理单元，这些都是从 C 语言继承过来的性质。\nCPP 对此进行了改良，使用 命名空间（namespace）来控制每个标识符的通用范围：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; namespace en { int x = 1; void print() { std::cout \u0026lt;\u0026lt; \u0026#34;en: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } } namespace zh { int x = 3; void print() { std::cout \u0026lt;\u0026lt; \u0026#34;zh: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } } int main() { en::print(); zh::print(); } 命名空间成员的声明和定义 属于命名空间的变量和函数等叫作 命名空间成员（namespace member）。可以在命名空间定义中只 声明 命名空间成员，在其他地方 定义 成员。\n1 2 3 4 5 6 7 8 9 10 11 12 // 声明 namespace jp { extern int x; void print(); } // --------------------------------------- // 定义 int jp::x = 4; void jp::print() { std::cout \u0026lt;\u0026lt; \u0026#34;jp: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } 嵌套命名空间 1 2 3 4 5 6 7 namespace Outer { int x; namespace Inner { int x; } } 在命名空间 Outer 中定义的 x 使用 Outer::x 访问，在命名空间 Inner 中定义的 x 使用 Outer::Inner::x 访问。\n无名命名空间 我们也可以定义没有名称的 无名命名空间（unnamed namespace），属于无名命名空间的成员的标识符 只在定义它的源文件中通用。 因此，这本质上相当于赋予标识符内部链接（同 static 的作用）。\n在 CPP 程序中，不推荐使用 static 来赋予比那辆和函数内部链接，建议使用功能更多且更具弹性的无名命名空间。\n同时，不推荐 static 的原因还在于其含义会根据上下文的不同而不同：\n对在函数中定义的变量添加 static 用来指定 静态存储期 对函数以及在函数外定义的变量添加的 static 用来指定 内部链接 对类的成员添加的 static 用来指定 静态成员 命名空间的别名的定义 命名空间不能重名，为了方便可以为较长的命名空间定义 别名：\n1 namespace en = English // 给 English 定义别名 en using 声明和指令 使用 using 声明可以子啊不使用作用域解析运算符的情况下，通过简单名称来访问标识符；使用 using 指令可以实现通过简单名称使用 属于某个命名空间的所有标识符。\n1 2 3 4 5 6 // using 指令，使用 std 命名空间的所有标识符 uisng namespace std; // using 声明，直接使用 en 命名空间下的 print using en::print(); print(); ","date":"2024-03-21T23:12:32+08:00","image":"https://3000ye.com/p/clear-c-ch09-function-application/assets/clearcpp_hu_c0d6f419ba1dddc3.jpg","permalink":"https://3000ye.com/p/clear-c-ch09-function-application/","title":"Clear C++ Ch09: Function application"},{"content":"线程管理 在程序开发中，很多时候都是程序都是串行处理，这没有什么问题。然而，在某些重复工作较多，且性能要求较高的场景，串行处理所需时间往往过于漫长。\n因此，合理地使用线程管理有助于我们程序的更好运行。但是请注意，不是一味地使用多线程或线程池就一定是好的，适合运行场景的处理方式才是最好的。\n单线程 在本文中，我们考虑这样一个场景：有一个非常耗时的计算函数，其计算一次需要 time 秒。\n1 2 3 4 5 6 void waitTime(int time) { std::chrono::seconds duration(time); std::this_thread::sleep_for(duration); std::cout \u0026lt;\u0026lt; \u0026#34;wait for \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; \u0026#34; seconds\u0026#34; \u0026lt;\u0026lt; std::endl; } 按照常规的做法，我们串行地对批量任务进行处理：\n1 2 3 4 5 6 7 8 9 int main() { std::vector\u0026lt;int\u0026gt; todoList(10, 3); for (auto time : todoList) { waitTime(time); } return 0; } 可以预见，这种处理方法会非常耗时。\n多线程 为了加速程序运行和处理的速度，我们可以使用多线程来并行处理。多线程的思想是：先将要进行的任务放入队列中，然后让这些任务同时运行，最终实现加速程序运行的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void mulTreads(std::vector\u0026lt;int\u0026gt; todoList, const int MaxThreads) { std::vector\u0026lt;std::unique_ptr\u0026lt;std::thread\u0026gt;\u0026gt; fetchingThreads; for (int i = 0, l = todoList.size(); i \u0026lt; l; i ++) { fetchingThreads.emplace_back(std::make_unique\u0026lt;std::thread\u0026gt;(waitTime, todoList[i])); if (fetchingThreads.size() \u0026gt;= MaxThreads) { fetchingThreads.front()-\u0026gt;join(); fetchingThreads.erase(fetchingThreads.begin()); } } for (auto \u0026amp;threadPtr : fetchingThreads) { threadPtr-\u0026gt;join(); } } int main() { std::vector\u0026lt;int\u0026gt; todoList(10, 3); mulTreads(todoList, 7); return 0; } 线程池 多线程虽好，但是频繁地创建和删除线程，同样会造成时间和空间的浪费。因此，线程池出现了，在每次任务完成之后，保留现有线程并继续处理下一个任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class ThreadPool { public: ThreadPool(size_t numThreads) : stop(false) { for (size_t i = 0; i \u0026lt; numThreads; ++i) { workers.emplace_back([this] { while (true) { std::function\u0026lt;void()\u0026gt; task; { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(queueMutex); condition.wait(lock, [this] { return stop || !tasks.empty(); }); if (stop \u0026amp;\u0026amp; tasks.empty()) return; task = std::move(tasks.front()); tasks.pop(); } task(); } }); } } // 添加任务到线程池 template\u0026lt;class F\u0026gt; void enqueue(F\u0026amp;\u0026amp; task) { { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(queueMutex); tasks.emplace(std::forward\u0026lt;F\u0026gt;(task)); } condition.notify_one(); } ~ThreadPool() { { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(queueMutex); stop = true; } condition.notify_all(); for (std::thread \u0026amp;worker : workers) worker.join(); } private: std::vector\u0026lt;std::thread\u0026gt; workers; std::queue\u0026lt;std::function\u0026lt;void()\u0026gt;\u0026gt; tasks; std::mutex queueMutex; std::condition_variable condition; bool stop; }; int main() { const int numThreads = 7; ThreadPool pool(numThreads); // 创建包含7个线程的线程池 std::vector\u0026lt;int\u0026gt; todoList(10, 3); // 向线程池中添加任务 for (const int\u0026amp; time : todoList) { pool.enqueue([time] { waitTime(time); }); } return 0; } ","date":"2024-03-18T21:06:19+08:00","permalink":"https://3000ye.com/p/threads/","title":"Threads"},{"content":"数据结构：链表 线性表 线性表是具有相同数据类型的 $n(n \\ge 0)$ 个数据元素的有限序列，其中 $n$ 为表长，当 $n = 0$ 时线性表是一个空表。若用 $L$ 命名线性表，则其一般表示为：\n$$ L = (a_1, a_2, \\cdots, a_i, a_{i + 1}, \\cdots, a_n) $$\n几个概念：\n$a_i$ 是线性表中的“第 $i$ 个”元素线性表中的位序，位序从 $1$ 开始，数组下标从 $0$ 开始。 $a_1$ 是表头元素，$a_n$ 是表尾元素。 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。\n线性表有两种存储方式，一种是顺序存储结构，另一种是链式存储结构。我们常用的数组就是一种典型的顺序存储结构。\n链表 链式存储结构就是两个相邻的元素在内存中可能不是相邻的，每一个元素都有一个指针域，指针域一般是存储着到下一个元素的指针。\n这种存储方式的优点是定点插入和定点删除的时间复杂度为 $O(1)$，缺点是访问的时间复杂度最坏为 $O(n)$。\n链表就是链式存储的线性表。根据指针域的不同，链表分为单向链表、双向链表、循环链表等等。\n单向链表 单向链表中包含数据域和指针域，其中数据域用于存放数据，指针域用来连接当前结点和下一节点。\n","date":"2024-02-21T19:14:32+08:00","image":"https://3000ye.com/p/linked-list/assets/dataStructures_hu_b53b87211490e84d.jpg","permalink":"https://3000ye.com/p/linked-list/","title":"Linked List"},{"content":"东华大学学术 Beamer 模板 本模板为东华大学专用的学术报告 Slides 的 LaTeX Beamer 模板使用说明，主要特点为：\n设计元素全部来源于东华大学 标识系统，浓浓的东华风。 Slides 整体风格借鉴了东华大学标准 PPT 模板与学术 PPT 模板（2020版，模板连接）。 简洁清晰的底部导航区让 Slides 更适合学术汇报使用。 前后端分离式设计，.tex 文件中只需聚焦内容，.sty 配置文件隔离存放。 使用 dhuBeamer 模板 认识 Beamer 中的元素 Beamer 根据元素在 Slides 中的不同作用，主要做了以下划分：\n修改 dhuBeamer 模板 ","date":"2024-02-16T23:33:47+08:00","image":"https://3000ye.com/p/dhubeamer/assets/latex_hu_845ccbc3e81fb8a3.jpg","permalink":"https://3000ye.com/p/dhubeamer/","title":"dhuBeamer"},{"content":"CppJson 第二章节：number 值解析 ","date":"2024-01-01T23:18:32+08:00","image":"https://3000ye.com/p/cppjson-ch02/assets/JSON-Tutorial_hu_12b092208874863c.jpg","permalink":"https://3000ye.com/p/cppjson-ch02/","title":"CppJson Ch02"},{"content":"用桌面变化来总结 2023 3月16日，我有 5 块屏幕 这段时间是我同时使用屏幕数量最多的时候，主屏幕写代码，副屏幕看网页；surface 和工控屏做直播推流；iPad 负责预览直播画面：\n主屏幕（中间）：27 寸 2k，副屏幕（最左）：15.6 寸 2k surface（最右），工控屏（最小）：7 寸 1080p iPad（非统一背景） 几乎每天都在宿舍，买了本《明解 C++》一边学语言一边学算法。虽然算法已经忘得差不多了，但坚实的 C++ 基础对我帮助很大，甚至我现在实习的主要内容就是 C++ 开发。\n5月10日，我有 2 块屏幕 学完了 C++ 语言基础后，我开始意识到数据结构对编程的重要性。同时也有为考研做准备的打算，我开始每天往返图书馆，刷王道考研的 CS408 课程。\n为了方便往返图书馆并尽可能满足我多屏幕的需求，买了一台可以 180 度开合的笔记本（ThinkBook 14）和一个立式支架，搭配 ThinkPad 的 GaN 100W 充电器和雷电线，只需 2 根线完成所有的连接。这样的好处是可以上面写代码下面看课程，同时使用外接键盘不会很突兀。\n6月18日，我有 2 块屏幕 春季学期结束后，我也放弃了考研的打算，开始往机器学习和 Pytorch 的方向学习。翻出以前买的西瓜书和南瓜书，对着 Github 上的开源笔记边看边学。由于宿舍桌子太窄了，放三块屏幕过于拥挤，于是将 15.6 寸的副屏收了起来。\n趁着 618 换了罗技的 master 3s 鼠标，手感确实比雷蛇的 click Pro 好很多。同时每天都坚持录视频，之前买的麦克风也派上了用场。\n7月19日，我有 1 块屏幕 随着 Pytorch 学习的深入，笔记本的核显已经无法满足需求。而此时矿潮已经开始逐渐褪去，随着 4090 的发布老显卡的价格开始走低，索性在咸鱼上淘了一张服务器版的 2080Ti：\n300A 核心，三星显存 纯铜涡轮散热，尾部供电 其 11G 的显存足以满足入门需求，同时后期还可以加焊 22G 显存，是一张性能和成长空间都不错的显卡。\n同时为了最大限度使用显卡，直接把机器刷成了 Ubuntu server，将之前的监控屏用来监控显卡状态。\n7月20日，我有 3 块屏幕 搞深度学习，真的是屏幕越多越好，有太多的资料和数据集看不过来：\n主显示器用来看资料 副显示器用来看数据集（竖直摆放） 笔记本屏幕用来写代码 9月6日，我有 1 块屏幕 秋季学期重回宿舍后，开始迷上了 Minecraft 和泡茶，一杯茶一个种子就是一天。这段时间是最放松的时间，每天都在搭方块。\n10月19日，我有 3 块屏幕 开始实习后，第一次用上了 MacOS。但尴尬的是，工作用的编译和测试环境还是 Windows，所以基本上都是在 Mac 上面通过 SSH 远程 Windows 进行开发（VsCode 大法好）：\n开发环境：MacBookPro（左边）和主屏幕：28 寸 4k 编译环境：dell Windows 主机（无屏幕） 测试环境：hp | ThinkPad（右边） 同时，我也负责服务器上的容器部署等相关工作，所以我有幸同时使用 3 大主流操作系统。\n12月31日，我有 2 块屏幕 适应实习的节奏后，晚上回宿舍的几个小时是每天最舒服的，因为可以不用管公司的事情专注自己喜欢的项目。\n趁着放假买了一块树莓派 4B 在宿舍折腾，初步搭了 Seafile 和 Gitlab。\n","date":"2023-12-31T15:40:26+08:00","image":"https://3000ye.com/p/2023-summary/assets/wakatime_hu_127a0d868c9d26ff.png","permalink":"https://3000ye.com/p/2023-summary/","title":"2023 Summary"},{"content":"创作极客喜欢的 PRD 产品需求文档（Product Requirements Document，PRD）是软件工程和互联网产品设计中的术语，是将商业需求文档（Business Requirements Document，BRD）和市场需求文档（Market Requirements Document，MRD）用更加专业的语言进行描述。\n产品需求文档，是交互设计的基础。通常包含了产品的理念宗旨、功能需求、逻辑架构、页面设计等信息。产品需求文档的撰写，是软件工程的重要阶段，对于把握产品需求、保证产品经理、设计师和软件开发者等人员之间的沟通有据有着重要意义。\n在实际的公司生产中，由于产品经理和开发人员之间往往会发生以下问题：\n产品经理辛苦写了 PRD，但开发人员却不用心看，或根本看不懂。 在开发过程中，开发人员反复确认相关细节，造成沟通的时间浪费。 开发完成后，项目结果远远不如预期。 因此，如何写一份用户体验好、开发喜欢看、靠谱的需求文档成为每个产品经理的必修课。\n产品简介 行业概要 发行版本 排期表 产品设计 实体关系图 用户角色权限表 function user1 user2 func 01 get get ","date":"2023-12-28T14:18:06+08:00","image":"https://3000ye.com/p/happy-geek-prd/assets/prd_hu_cd7a13d1efd3e142.jpg","permalink":"https://3000ye.com/p/happy-geek-prd/","title":"Happy Geek PRD"},{"content":"为不同的 Git 服务生成不同的 SSH Key 在一台设备上使用 Git 托管代码时，我们可能会遇到以下需求：\n我有多个 Git 平台（Github, Gitlab, \u0026hellip;）的账号，每个平台的账号都需要一个 SSH Key。 在同一个 Git 平台，我有多个账号，每个账号都需要一个 SSH Key。 不同平台的账号，可能使用相同邮箱进行注册。 这时，如何生成和管理 SSH Key 成为一个问题。\n设置局部 Git 信息 在不同文件夹下，都可以设置不同的局部 Git 信息：\n1 2 git config user.name \u0026#34;name\u0026#34; git config user.email \u0026#34;email\u0026#34; 开启 SSH Agent 开启 SSH Agent 对 SSH 执行代理，用于缓存私钥：\n1 eval \u0026#34;$(ssh-agent -s)\u0026#34; 生成不同的 SSH Key 指定文件名，生成不同的 SSH Key，即使相同邮箱也可以进行区分：\n1 ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa_name -C \u0026#34;your_email@example.com\u0026#34; 将生成的私钥添加进代理：\n1 2 3 4 ssh-add ~/.ssh/id_rsa_name # MacOS ssh-add --apple-use-keychain ~/.ssh/id_rsa_name 将公钥添加到 Git 平台 首先复制 SSH 公钥：\n1 cat ~/.ssh/id_rsa_name.pub 然后到 Git 平台中，添加该公钥。\n","date":"2023-12-26T16:23:26+08:00","image":"https://3000ye.com/p/ssh-key-agent/assets/gitssh_hu_586f4872f5cd401d.png","permalink":"https://3000ye.com/p/ssh-key-agent/","title":"SSH Key Agent"},{"content":"飞书机器人监听 Gitlab 项目 在服务器部署定时任务（爬虫、拉取数据库、模型训练等），任务完成后自动填写 commit 信息，并 push 到 Gitlab。\n使用飞书机器人自动监听 Gitlab 项目，并获取 commit 信息，最终发送到飞书指定用户或群聊。\n准备工作 实现这个功能，你需要准备：\n电子邮箱：用于创建 Gitlab 账号和绑定 SSH 秘钥。 飞书账号：用于创建机器人监听 Gitlab 项目。 服务器（Linux）：用于部署任务，并自动 push 到 Gitlab。 创建 Gitlab 账号并新建项目 使用准备好的邮箱，注册 Gitlab 账号：https://gitlab.com/\n注册完成后新建一个新项目，并添加一个 README.md 文件。\n配置 SSH 秘钥 使用 Terminal 连接你的服务器，使用以下命令（Ubuntu 22.04）：\n1 2 3 4 5 6 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade sudo apt install git git config --global user.name \u0026#34;name\u0026#34; git config --global user.email \u0026#34;email\u0026#34; ssh-keygen -C \u0026#34;email\u0026#34; -t rsa cat ~/.ssh/id_rsa.pub 其中 name 为 Gitlab 账号的名称，email 为 Gitlab 账号的邮箱，将输出的内容复制到剪切板。\n然后在 Gitlab 中，进入用户设置，找到 SSH 秘钥然后选择添加新秘钥，粘贴剪切板的内容保存即可。\nClone 项目并配置任务 在 Gitlab 中打开项目，点击右上角的代码，复制使用 SSH 克隆的链接：\n然后在 Terminal 中找到合适的位置，Clone 项目：\n1 git clone git@gitlab.com:xxxxxxxxxxxxxxxxxx.git 编写你的任务脚本（shell 或 Python 等），然后确保其能正常运行。\n新建飞书指令 使用飞书机器人助手，新建机器人指令，触发器选择 [新的 commit 创建]，按照教程绑定 Gitlab 账号和项目：\n然后选择操作 [通过官方机器人发消息]，设置消息内容为 commit 说明，并选择发送目标：\n点击完成后，启用机器人即可。\n创建定时任务 首先测试飞书机器人是否能够正常抓取 Gitlab 项目的 commit，测试成功后，在服务器上为任务创建定时任务。\n本文推荐使用 systemctl 和 systemd 的 timer 来创建定时任务。\n创建定时器配置 创建一个 task.timer 文件：\n1 2 3 4 5 6 7 8 9 10 [Unit] Description=Your Timer Description [Timer] # OnCalendar设置定时规则，这里是每天10点 OnCalendar=*-*-* 10:00:00 Unit=xxxxx.service [Install] WantedBy=timers.target 创建定时器服务 创建一个 task.service 文件（默认使用 root 用户，建议指定 User 用户）：\n1 2 3 4 5 6 7 8 [Unit] Description=Your Service Description [Service] Type=simple User=user # 建议使用 shell 脚本 ExecStart=/path/to/your/script.sh 添加定时任务 1 2 3 4 5 6 7 8 9 sudo cp your_timer_name.timer /etc/systemd/system/ sudo cp your_service_name.service /etc/systemd/system/ sudo systemctl daemon-reload # 手动启用任务，测试任务是否正常运行 sudo systemctl enable your_timer_name.timer sudo systemctl start your_timer_name.service sudo systemctl list-timers 任务运行成功后，使用以下命令查看日志：\n1 2 # 输出任务运行日志 sudo journalctl -u your_timer_name.service ","date":"2023-12-22T13:47:39+08:00","image":"https://3000ye.com/p/feishu-robot/assets/feishuGitlab_hu_66371f3fe078be32.png","permalink":"https://3000ye.com/p/feishu-robot/","title":"Feishu Robot"},{"content":"CppJson 第一章节：自动测试，NULL 和 bool 值解析 JSON 是什么 JSON（JavaScript Object Notation）是一个用于数据交换的文本格式，现时的标准为ECMA-404。\n虽然 JSON 源至于 JavaScript 语言，但它只是一种数据格式，可用于任何编程语言。现时具类似功能的格式有 XML、YAML，当中以 JSON 的语法最为简单。\n例如，一个动态网页想从服务器获得数据时，服务器从数据库查找数据，然后把数据转换成 JSON 文本格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;title\u0026#34;: \u0026#34;Design Patterns\u0026#34;, \u0026#34;subtitle\u0026#34;: \u0026#34;Elements of Reusable Object-Oriented Software\u0026#34;, \u0026#34;author\u0026#34;: [ \u0026#34;Erich Gamma\u0026#34;, \u0026#34;Richard Helm\u0026#34;, \u0026#34;Ralph Johnson\u0026#34;, \u0026#34;John Vlissides\u0026#34; ], \u0026#34;year\u0026#34;: 2009, \u0026#34;weight\u0026#34;: 1.8, \u0026#34;hardcover\u0026#34;: true, \u0026#34;publisher\u0026#34;: { \u0026#34;Company\u0026#34;: \u0026#34;Pearson Education\u0026#34;, \u0026#34;Country\u0026#34;: \u0026#34;India\u0026#34; }, \u0026#34;website\u0026#34;: null } 网页的脚本代码就可以把此 JSON 文本解析为内部的数据结构去使用。\n从此例子可看出，JSON 是树状结构，而 JSON 只包含 6 种数据类型：\nnull: 表示为 null boolean: 表示为 true 或 false number: 一般的浮点数表示方式，在下一单元详细说明 string: 表示为 \u0026ldquo;\u0026hellip;\u0026rdquo; array: 表示为 [ \u0026hellip; ] object: 表示为 { \u0026hellip; } 我们要实现的 JSON 库，主要是完成 3 个需求：\n把 JSON 文本解析为一个树状数据结构（parse）。 提供接口访问该数据结构（access）。 把数据结构转换成 JSON 文本（stringify）。 我们会逐步实现这些需求。在本章节中，我们只实现最简单的 null 和 boolean 解析。\n搭建编译环境 我们要做的库是跨平台、跨编译器的，同学可使用任意平台进行练习。\n我们的 JSON 库名为 CppJson，代码文件只有 3 个：\ninclude/cppjson.hpp：CppJson 的头文件（header file），含有对外的类型和 API 函数声明。 cppjson.cpp：CppJson 的实现文件（implementation file），含有内部的类型声明和函数实现。此文件会编译成库。 cppjsonTest.cpp：我们使用测试驱动开发（test driven development, TDD）。此文件包含测试程序，需要链接 CppJson 库。 为了方便跨平台开发，我们会使用一个现时最流行的软件配置工具 CMake。\n在 OS X 平台中，在命令行通过命令：\n1 2 3 4 mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Debug .. make 将 Debug 改成 Release 就会生成 Release 配置的 makefile。\n在 Vscode 中，可以通过配置 tasks.json 文件来进行自动 build：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //.vscode/tasks.json { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;mkdirbuild\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;mkdir\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;args\u0026#34;: [\u0026#34;-p\u0026#34;, \u0026#34;build\u0026#34;] }, { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;cmake\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;cmake\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-DCMAKE_BUILD_TYPE=Debug\u0026#34;, //在此处添加其它CMAKE选项 \u0026#34;..\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}/build\u0026#34; }, }, { \u0026#34;label\u0026#34;: \u0026#34;make\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;make\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;-j16\u0026#34;,], //根据机器cpu核心数量自行调整 \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}/build\u0026#34; }, }, { \u0026#34;label\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;dependsOrder\u0026#34;: \u0026#34;sequence\u0026#34;, \u0026#34;dependsOn\u0026#34;: [\u0026#34;mkdirbuild\u0026#34;, \u0026#34;cmake\u0026#34;, \u0026#34;make\u0026#34;], }, ], } 然后执行 build 生成的文件：\n1 2 3 $ ./build/cppjson_test_ch01 16/16 (100.00%) passed 若看到类似以上的结果，说明已成功搭建编译环境，我们可以去看看那几个代码文件的内容了。\n头文件与 API 设计 Cpp 语言有头文件的概念，需要使用 #include去引入头文件中的类型声明和函数声明。但由于头文件也可以 #include 其他头文件，为避免重复声明，通常会利用宏加入 include 防范（include guard）：\n1 #pragma once 如前所述，JSON 中有 6 种数据类型，如果把 true 和 false 当作两个类型就是 7 种，我们为此声明一个枚举类（enumeration calss）：\n1 2 3 4 5 6 7 8 9 enum class cppjsonType { CPPJSON_NULL, CPPJSON_TRUE, CPPJSON_FALSE, CPPJSON_NUMBER, CPPJSON_STRING, CPPJSON_ARRAY, CPPJSON_OBJECT }; 接下来，我们声明 JSON 的数据结构。JSON 是一个树形结构，我们最终需要实现一个树的数据结构，每个节点使用 cppjson_value 结构体表示，我们会称它为一个 JSON 值（JSON value）。\n在此单元中，我们只需要实现 null, true 和 false 的解析，因此该结构体只需要存储一个 cppjsonType，之后的单元会逐步加入其他数据。\n1 2 3 typedef struct { cppjsonType type; } cppjson_value; 然后，我们现在只需要两个 API 函数，一个是解析 JSON：\n1 cppjsonParseCode cppjson_parse(cppjson_value* v, const std::string json); 传入的 JSON 文本是一个 string 字符串，由于我们不应该改动这个输入字符串，所以使用 const std::string 类型。\n返回值是以下这些枚举类中的值，无错误会返回 cppjsonParseCode::OK，其他值在下节解释。\n1 2 3 4 5 6 enum class cppjsonParseCode { OK, EXPECT_VALUE, INVALID_VALUE, ROOT_NOT_SINGULAR }; 现时我们只需要一个访问结果的函数，就是获取其类型：\n1 cppjsonType cppjson_get_type(const cppjson_value* v); JSON 语法子集 下面是此单元的 JSON 语法子集，使用 RFC7159 中的 ABNF 表示：\n1 2 3 4 5 6 JSON-text = ws value ws ws = *(%x20 / %x09 / %x0A / %x0D) value = null / false / true null = \u0026#34;null\u0026#34; false = \u0026#34;false\u0026#34; true = \u0026#34;true\u0026#34; 当中 %xhh 表示以 16 进制表示的字符，/ 是多选一，* 是零或多个，() 用于分组。\n那么第一行的意思是，JSON 文本由 3 部分组成，首先是空白（whitespace），接着是一个值，最后是空白。\n第二行告诉我们，所谓空白，是由零或多个空格符（space U+0020）、制表符（tab U+0009）、换行符（LF U+000A）、回车符（CR U+000D）所组成。\n第三行是说，我们现时的值只可以是 null、false 或 true，它们分别有对应的字面值（literal）。\n我们的解析器应能判断输入是否一个合法的 JSON。如果输入的 JSON 不合符这个语法，我们要产生对应的错误码，方便使用者追查问题。\n在这个 JSON 语法子集下，我们定义 3 种错误码：\n若一个 JSON 只含有空白，传回 LEPT_PARSE_EXPECT_VALUE。 若一个值之后，在空白之后还有其他字符，传回 LEPT_PARSE_ROOT_NOT_SINGULAR。 若值不是那三种字面值，传回 LEPT_PARSE_INVALID_VALUE。 单元测试 许多同学在做练习题时，都是以 printf／cout 打印结果，再用肉眼对比结果是否乎合预期。但当软件项目越来越复杂，这个做法会越来越低效。一般我们会采用自动的测试方式，例如单元测试（unit testing）。单元测试也能确保其他人修改代码后，原来的功能维持正确（这称为回归测试／regression testing）。\n常用的单元测试框架有 xUnit 系列，如 C++ 的 Google Test、C# 的 NUnit。我们为了简单起见，会编写一个极简单的单元测试方式。\n一般来说，软件开发是以周期进行的。例如，加入一个功能，再写关于该功能的单元测试。但也有另一种软件开发方法论，称为测试驱动开发（test-driven development, TDD），它的主要循环步骤是：\n加入一个测试。 运行所有测试，新的测试应该会失败。 编写实现代码。 运行所有测试，若有测试失败回到3。 重构代码。 回到 1。 TDD 是先写测试，再实现功能。好处是实现只会刚好满足测试，而不会写了一些不需要的代码，或是没有被测试的代码。\n但无论我们是采用 TDD，或是先实现后测试，都应尽量加入足够覆盖率的单元测试。\n回到 CppJson 项目，cppjsonTest.cpp 包含了一个极简的单元测试框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026#34;include/cppjson.hpp\u0026#34; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;typeinfo\u0026gt; static int main_ret = 0; static int test_count = 0; static int test_pass = 0; // 测试宏接口 // flag 表示测试点是否通过，如果未通过则打印异常信息 #define EXPECT_BASE(flag, expect, actual) \\ do {\\ test_count ++;\\ if (flag) test_pass ++;\\ else {\\ fprintf(stderr, \u0026#34;%s:%d, expect = %s(%d), actual = %s(%d)\\n\u0026#34;, __FILE__, __LINE__, typeid(expect).name(), static_cast\u0026lt;int\u0026gt;(expect), typeid(actual).name(), static_cast\u0026lt;int\u0026gt;(actual));\\ main_ret = 1;\\ }\\ } while(0) #define EXPECT_TYPE(expect, actual) EXPECT_BASE((expect) == (actual), expect, actual) // static void test_parse_null() { cppjson_value v; v.type = cppjsonType::CPPJSON_FALSE; EXPECT_TYPE(cppjsonParseCode::OK, cppjson_parse(\u0026amp;v, \u0026#34;null\u0026#34;)); EXPECT_TYPE(cppjsonType::CPPJSON_NULL, cppjson_get_type(\u0026amp;v)); } static void test_parse() { test_parse_null(); // ... } int main() { test_parse(); printf(\u0026#34;%d/%d (%3.2f%%) passed\\n\u0026#34;, test_pass, test_count, test_pass * 100.0 / test_count); return main_ret; } 现时只提供了一个 EXPECT_TYPE(expect, actual) 的宏，每次使用这个宏时，如果 expect != actual（预期值不等于实际值），便会输出错误信息。\n若按照 TDD 的步骤，我们先写一个测试，如上面的 test_parse_null()，而 cppjson_parse() 只返回 cppjsonParseCode::OK：\n1 2 /CppJson/ch01/cppjsonTest.cpp:30, expect = 16cppjsonParseCode(0), actual = 16cppjsonParseCode(2) 15/16 (93.75%) passed 为通过的测试是因为 cppjson_parse() 没有把 v.type 改成 cppjsonType::CPPJSON_NULL，造成失败。我们再实现 lept_parse() 令到它能通过测试。\n然而，完全按照 TDD 的步骤来开发，是会减慢开发进程。所以我个人会在这两种极端的工作方式取平衡。通常会在设计 API 后，先写部分测试代码，再写满足那些测试的实现。\n实现解析器 有了 API 的设计、单元测试，终于要实现解析器了。\n首先为了减少解析函数之间传递多个参数，我们把这些数据都放进一个 cppjson_context 结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef struct { std::string json; } cppjson_context; // json 解析函数：ws1 value ws2 cppjsonParseCode cppjson_parse(cppjson_value *v, const std::string json) { cppjson_context s; s.json = json; assert(v != NULL); v-\u0026gt;type = cppjsonType::CPPJSON_NULL; // 分别解析 ws1 value ws2 cppjson_parse_whitespace(\u0026amp;s); auto ret = cppjson_parse_value(\u0026amp;s, v); return ret == cppjsonParseCode::OK ? cppjson_parse_root_not_singular(\u0026amp;s) : ret; } CppJson 是一个手写的递归下降解析器（recursive descent parser）。由于 JSON 语法特别简单，我们不需要写分词器（tokenizer），只需检测下一个字符，便可以知道它是哪种类型的值，然后调用相关的分析函数。对于完整的 JSON 语法，跳过空白后，只需检测当前字符：\nn ➔ null t ➔ true f ➔ false \u0026quot; ➔ string 0-9/- ➔ number [ ➔ array { ➔ object 所以，我们可以按照 JSON 语法一节的 EBNF 简单翻译成解析函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 删除空白符 static void cppjson_parse_whitespace(cppjson_context* s) { const std::string str = s-\u0026gt;json; int i = 0; while (str[i] == \u0026#39; \u0026#39; or str[i] == \u0026#39;\\t\u0026#39; or str[i] == \u0026#39;\\n\u0026#39; or str[i] == \u0026#39;\\r\u0026#39;) { i ++; } s-\u0026gt;json = str.substr(i, str.size()); } // 解析 ws2 之后是否还有非空值 static cppjsonParseCode cppjson_parse_root_not_singular(cppjson_context* s) { // 删除空白符 cppjson_parse_whitespace(s); // 判断是否还有非空值 if (s-\u0026gt;json[0] != \u0026#39;\\0\u0026#39;) return cppjsonParseCode::ROOT_NOT_SINGULAR; else return cppjsonParseCode::OK; } // 检测 null 值 static cppjsonParseCode cppjson_parse_null(cppjson_context* s, cppjson_value* v) { const std::string str = s-\u0026gt;json; auto head = str.substr(0, 4); if (head != \u0026#34;null\u0026#34;) return cppjsonParseCode::INVALID_VALUE; else { s-\u0026gt;json = str.substr(4, str.size()); v-\u0026gt;type = cppjsonType::CPPJSON_NULL; return cppjsonParseCode::OK; } } // 解析 value static cppjsonParseCode cppjson_parse_value(cppjson_context* s, cppjson_value* v) { const std::string str = s-\u0026gt;json; switch (str[0]) { case \u0026#39;n\u0026#39;: return cppjson_parse_null(s, v); case \u0026#39;t\u0026#39;: return cppjson_parse_true(s, v); case \u0026#39;f\u0026#39;: return cppjson_parse_false(s, v); case \u0026#39;\\0\u0026#39;: return cppjsonParseCode::EXPECT_VALUE; default: return cppjsonParseCode::INVALID_VALUE; } } ","date":"2023-12-16T23:33:44+08:00","image":"https://3000ye.com/p/cppjson-ch01/assets/JSON-Tutorial_hu_12b092208874863c.jpg","permalink":"https://3000ye.com/p/cppjson-ch01/","title":"CppJson Ch01"},{"content":"顺序容器 一个容器就是一些特定类型对象的集合，顺序容器（sequence container） 为程序员提供了控制元素存储和访问顺序的能力。\n顺序容器概述 下面列出了标准库中的顺序容器，不同容器有不同的性能折中：\n想容器添加或从容器删除元素的代价。 非顺序访问容器中元素的代价。 容器类型 介绍 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。 list 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。 forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 array 固定大小数组。支持快速随机访问。不能添加或者删除元素。 string 与vector相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 除了固定大小的 array 外，其他容器都提供高效、灵活的内存管理。 通常使用 vector 是最好的选择，除非你有很好的理由选择其他容器。 如果程序中有很多小的元素，且空间的额外开销很重要，则不要使用 list 或 forward_list。 如果程序要求随记访问元素，应使用 vector 或 deque。 如果程序要求在容器的中间插入或删除元素，应使用 list 或 forward_list。 如果程序需要再头尾位置插入或删除元素，但不会再中间位置进行操作，应使用 deque。 容器库概念 容器类型操作上形成了一种层次：\n某些操作是所有容器类型都提供的。 另一些操作仅针对顺序容器、关联容器或无序容器。 类型 操作 解释 iterator 此容器类型的迭代器类型 const_iterator 可以读取元素但不能修改元素的迭代器类型 size_type 无符号整数类型，足够保存此种容器类型最大可能的大小 difference_type 带符号整数类型，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型；和value_type \u0026amp;含义相同 const_reference 元素的const左值类型，即const value_type \u0026amp; 构造函数 操作 解释 C c; 默认构造函数，构造空容器 C c1(c2);或C c1 = c2; 构造c2的拷贝c1 C c(b, e) 构造c，将迭代器b和e指定范围内的所有元素拷贝到c C c(a, b, c...) 列表初始化c C c(n) 只支持顺序容器，且不包括array，包含n个元素，这些元素进行了值初始化 C c(n, t) 包含n个初始值为t的元素 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。 array具有固定大小。 和其他容器不同，默认构造的array是非空的。 直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。 使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。 赋值和swap 操作 解释 c1 = c2; 将c1中的元素替换成c2中的元素 c1 = {a, b, c...} 将c1中的元素替换成列表中的元素（不适用于array） c1.swap(c2) 交换c1和c2的元素 swap(c1, c2) 等价于c1.swap(c2) c.assign(b, e) 将c中的元素替换成迭代器b和e表示范围中的元素，b和e不能指向c中的元素 c.assign(il) 将c中的元素替换成初始化列表il中的元素 c.assign(n, r) 将c中的元素替换为n个值是t的元素 使用非成员版本的swap是一个好习惯。 assign操作不适用于关联容器和array 大小 操作 解释 c.size() c中元素的数目（不支持forward_list） c.max_size() c中可保存的最大元素数目 c.empty() 若c中存储了元素，返回false，否则返回true 添加元素 操作 解释 c.push_back(t) 在c尾部创建一个值为t的元素，返回void c.emplace_back(args) 同上 c.push_front(t) 在c头部创建一个值为t的元素，返回void c.emplace_front(args) 同上 c.insert(p, t) 在迭代器p指向的元素之前创建一个值是t的元素，返回指向新元素的迭代器 c.emplace(p, args) 同上 c.insert(p, n, t) 在迭代器p指向的元素之前插入n个值为t的元素，返回指向第一个新元素的迭代器；如果n是0，则返回p c.insert(p, b, e) 将迭代器b和e范围内的元素，插入到p指向的元素之前；如果范围为空，则返回p c.insert(p, il) il是一个花括号包围中的元素值列表，将其插入到p指向的元素之前；如果il是空，则返回p 因为这些操作会改变大小，因此不适用于array。 forward_list有自己专有版本的insert和emplace。 forward_list不支持push_back和emplace_back。 当我们用一个对象去初始化容器或者将对象插入到容器时，实际上放入的是对象的拷贝。 emplace开头的函数是新标准引入的，这些操作是构造而不是拷贝元素。 传递给emplace的参数必须和元素类型的构造函数相匹配。 访问元素 操作 解释 c.back() 返回c中尾元素的引用。若c为空，函数行为未定义 c.front() 返回c中头元素的引用。若c为空，函数行为未定义 c[n] 返回c中下标是n的元素的引用，n时候一个无符号证书。若n\u0026gt;=c.size()，则函数行为未定义 c.at(n) 返回下标为n的元素引用。如果下标越界，则抛出out_of_range异常 访问成员函数返回的是引用。 at和下标操作只适用于string、vector、deque、array。 back不适用于forward_list。 如果希望下标是合法的，可以使用at函数。 删除元素 操作 解释 c.pop_back() 删除c中尾元素，若c为空，则函数行为未定义。函数返回void c.pop_front() 删除c中首元素，若c为空，则函数行为未定义。函数返回void c.erase(p) 删除迭代器p指向的元素，返回一个指向被删除元素之后的元素的迭代器，若p本身是尾后迭代器，则函数行为未定义 c.erase(b, e) 删除迭代器b和e范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则返回尾后迭代器 c.clear() 删除c中所有元素，返回void 会改变容器大小，不适用于array。 forward_list有特殊版本的erase forward_list不支持pop_back vector和string不支持pop_front 特殊的 forwad_list操作 链表在删除元素时需要修改前置节点的内容，双向链表会前驱的指针，但是单向链表没有保存，因此需要增加获取前置节点的方法。 forward_list定义了before_begin，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。 操作 解释 lst.before_begin() 返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。 lst.cbefore_begin() 同上，但是返回的是常量迭代器。 lst.insert_after(p, t) 在迭代器p之后插入元素。t是一个对象 lst.insert_after(p, n, t) 在迭代器p之后插入元素。t是一个对象，n是数量。若n是0则函数行为未定义 lst.insert_after(p, b, e) 在迭代器p之后插入元素。由迭代器b和e指定范围。 lst.insert_after(p, il) 在迭代器p之后插入元素。由il指定初始化列表。 emplace_after(p, args) 使用args在p之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义。 lst.erase_after(p) 删除p指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义。 lst.erase_after(b, e) 类似上面，删除对象换成从b到e指定的范围。 改变容器大小 操作 解释 c.resize(n) 调整c的大小为n个元素，若n\u0026lt;c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 c.resize(n, t) 调整c的大小为n个元素，任何新添加的元素都初始化为值t 获取迭代器 操作 解释 c.begin(), c.end() 返回指向c的首元素和尾元素之后位置的迭代器 c.cbegin(), c.cend() 返回const_iterator 以c开头的版本是C++11新标准引入的 当不需要写访问时，应该使用cbegin和cend。 反向容器的额外成员 操作 解释 reverse_iterator 按逆序寻址元素的迭代器 const_reverse_iterator 不能修改元素的逆序迭代器 c.rbegin(), c.rend() 返回指向c的尾元素和首元素之前位置的迭代器 c.crbegin(), c.crend() 返回const_reverse_iterator 不支持forward_list ","date":"2023-12-10T15:58:28+08:00","image":"https://3000ye.com/p/c-primer-ch09/assets/c++primer_hu_d7e9cfb8d681b79f.jpg","permalink":"https://3000ye.com/p/c-primer-ch09/","title":"C++ Primer Ch09"},{"content":"IO 库 我们的程序已经使用了很多 IO 库设施：\nistream （输入流）类型，提供输入操作。 ostream （输出流）类型，提供输出操作。 cin，一个 istream 对象，从标准输入读取数据。 cout，一个 ostream 对象，想标准输出写入数据。 cerr，一个 ostream 对象，通常用于输出程序错误信息，写入到标准错误。 \u0026gt;\u0026gt; 运算符，用来从一个 istream 对象中读取输入数据。 \u0026lt;\u0026lt; 运算符，用来向一个 ostream 对象中写入输出数据。 getline 函数，从一个给定的 istream 对象中读取一行数据，存入到一个给定的 string 对象中。 IO 库 IO 类型和对象一般都是操纵 char 数据的，但有些使用需要对文件、string 进行操作，因此分别定义了三个头文件：\niostream 头文件：从标准流中读写数据，istream、ostream 等。 fstream 头文件：从文件中读写数据，ifstream、ofstream 等。 sstream 头文件：从字符串中读写数据，istringstream、ostringstream 等。 ","date":"2023-12-10T15:24:27+08:00","image":"https://3000ye.com/p/c-primer-ch08/assets/c++primer_hu_d7e9cfb8d681b79f.jpg","permalink":"https://3000ye.com/p/c-primer-ch08/","title":"C++ Primer Ch08"},{"content":"类 类的基本思想是 数据抽象（data abstraction） 和 封装（encapsulation）。数据抽象是一种依赖于 接口（interface） 和 实现（implementation） 分离的编程（及设计）技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。\n封装实现了类的接口和实现的分离，封装后的类隐藏了它的实现细节，即类的用户只能使用接口而无法访问实现部分。\n类要想实现数据抽象和封装，首先需要定义一个 抽象数据类型（abstract data type）。\n定义抽象数据类型 访问控制与封装 我们为类定义了接口之后，没有任何机制强制用户使用这些接口，我们的类还没有进行封装。在 C++ 中使用 访问说明符（access specifiers） 加强类的封装：\n定义在 public 说明符之后的成员，在整个程序内都可被访问。 定义在 private 说明符之后的成员，只能被类的成员访问，即隐藏了这些成员的实现。 定义新的 Sales_data 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Sales_data { private: std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; double avg_price() const { return units_sold ? revenue / units_sold : 0; } public: Sales_data() = default; Sales_data(const std::string \u0026amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p * n) {} Sales_data(const std::string \u0026amp;s): bookNo(s) {} Sales_data(std::istream\u0026amp;); std::string isbn() const { return bookNo; }; Sales_data \u0026amp;combine(const Sales_data\u0026amp;); }; ","date":"2023-12-10T14:35:42+08:00","image":"https://3000ye.com/p/c-primer-ch07/assets/c++primer_hu_d7e9cfb8d681b79f.jpg","permalink":"https://3000ye.com/p/c-primer-ch07/","title":"C++ Primer Ch07"},{"content":"函数 函数是一个命名了的代码块，我们通过调用函数执行响应的代码。函数可以有 0 个或多个参数，而且（通常）会返回一个结果。可以重载函数，即同一个名字可以对应几个不同的函数。\n函数基础 一个典型的 函数（function） 定义包括以下部分：返回类型（return type）、函数名字、由 0 个或多个 形参（parameter） 组成的列表以及函数体。\n我们通过 调用运算符（call operator） 来执行函数：调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号之内是一个用逗号隔开的 实参（argument） 列表，我们用实参初始化函数的形参，调用表达式的类型就是函数返回的类型。\n编写函数：例如编写一个求 n 的阶乘的函数：\n1 2 3 4 5 6 7 8 int fact(int n) { int res = 1; while (n \u0026gt; 1) { res *= n --; } return res; } 调用函数：要调用 fact 函数，首先需要提供一个整数，得到的返回结果也是一个整数值：\n1 2 3 4 5 6 int main() { int x = fact(5); cout \u0026lt;\u0026lt; \u0026#34;5! = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } 函数的调用完成两项工作：实参初始化函数对应的形参，将控制权转移给被调函数。此时，主调函数（calling funciton） 的执行暂停，被调函数（called funciton） 开始执行。\n局部对象 在 C++ 语言中，名字有作用域，对象有 生命周期（lifetime）：\n名字的作用域是程序文本的一部分，名字在其中可见。 对象的生命周期是程序执行过程中该对象存在的一段时间。 在函数体内，形参和内部定义的变量统称为 局部变量（local variable），它们对函数而言是“局部”饿，仅在函数的作用域内可见，同时局部变量还会 **隐藏（hide）**在外层作用域中同名的其他声明中。\n局部静态对象：某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成 static 类型从而获得这样的对象，局部静态对象（local static object） 在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。\n参数传递 ","date":"2023-12-08T21:13:28+08:00","image":"https://3000ye.com/p/c-primer-ch06/assets/c++primer_hu_d7e9cfb8d681b79f.jpg","permalink":"https://3000ye.com/p/c-primer-ch06/","title":"C++ Primer Ch06"},{"content":"表达式 表达式由一个或多个 运算对象（operand） 组成对表达式求值将得到一个 结果（result）。\n基础 基本概念 C++ 定义了一元运算符（unary operator）和二元运算符（binary operator），分别作用于一个运算对象和两个运算对象。此外，还有三元运算符，有些运算符既是一元也是二元运算符。\n对于含有多个运算符的复杂表达式，首先需要理解运算符的：优先级（precedence）、结合律（associativity）以及运算对象的求值顺序（order of evaluation）。\n在表达式求值过程中，小整数类型（bool、char、short）等通常会被 提升（promoted） 成较大的整数类型（int）。\n当运算符作用在类类型的运算对象时，用户可以自定定义其含义，称为 重载运算符（overloaded operator）。\nC++ 的表达式要不然是 右值（rvalue），要不然就是 左值（lvalue），这两个名词是从 C 继承过来的。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。\n求值顺序 在大多数情况下，表达式求值的顺序是没有明确指定的：\n1 int i = f1() * f2() 我们知道 f1 和 f2 一定会在执行乘法之前被调用，但是无法知道是 f1 先被调用还是 f2 先被调用。对于没有指定调用顺序的程序来说，如果 f1 和 f2 同时修改了同一个对象，将会引发错误并产生未定义的行为。\n算术运算符 溢出：当计算的结果超出该类型所能表示的范围时就会产生溢出。\nbool 类型不应该参与计算。\n取余运算：m % n 的结果的符号与 m 相同。\n逻辑运算符 短路求值：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值，再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。\n赋值运算符 ","date":"2023-11-28T08:49:13+08:00","image":"https://3000ye.com/p/c-primer-ch04/assets/c++primer_hu_d7e9cfb8d681b79f.jpg","permalink":"https://3000ye.com/p/c-primer-ch04/","title":"C++ Primer Ch04"},{"content":"字符串、向量和数组 命名空间的 using 声明 我们使用的库函数都有一个对应的命名空间，通常需要在声明或初始化变量时指定命名空间。为了简化这个操作，我们可以使用using进行声明：\n1 2 3 using std::cout; // 单独使用某个函数 using namespace std; // 批量声明 std 中所有函数 头文件中不应该包含 using 声明，这样使用了该头文件的源文件也会使用这个声明，会带来风险。\n标准库类型 string 标准库类型 string 表示可变长的字符序列，使用 string 类型必须首先包含 string 头文件：\n1 2 3 #include \u0026lt;string\u0026gt; using std::string 定义和初始化 string 对象 初始化 string 对象的方式：\n方式 解释 string s1 默认初始化，s1是个空字符串 string s2(s1) s2是s1的副本 string s2 = s1 等价于s2(s1)，s2是s1的副本 string s3(\u0026quot;value\u0026quot;) s3是字面值“value”的副本，除了字面值最后的那个空字符外 string s3 = \u0026quot;value\u0026quot; 等价于s3(\u0026quot;value\u0026quot;)，s3是字面值\u0026quot;value\u0026quot;的副本 string s4(n, 'c') 把s4初始化为由连续n个字符c组成的串 拷贝初始化（copy initialization）：使用 = 将一个已有的对象拷贝到正在创建的对象。\n直接初始化（direct initialization）：通过括号给对象赋值。\nstring 对象的操作 string的操作：\n操作 解释 os \u0026lt;\u0026lt; s 将s写到输出流os当中，返回os is \u0026gt;\u0026gt; s 从is中读取字符串赋给s，字符串以空白分割，返回is getline(is, s) 从is中读取一行赋给s，返回is s.empty() s为空返回true，否则返回false s.size() 返回s中字符的个数 s[n] 返回s中第n个字符的引用，位置n从0计起 s1+s2 返回s1和s2连接后的结果 s1=s2 用s2的副本代替s1中原来的字符 s1==s2 如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感 s1!=s2 同上 \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） 读取 string 对象：\n使用 IO 操作符 \u0026gt;\u0026gt; 读取：忽略开头的空白（空格符、换行符、制表符等），从第一个真正的字符开始读起，直到遇到下一个空白。 使用 getline() 函数读取：将一整行读取为 string 对象，包括空白。 s.size() 返回 string::size_type 类型，是 无符号 类型的值，不能和 int 混用。\ns1 + s2 使用时，必须保证至少其中一个为 string 类型。例如：string s = \u0026quot;hello\u0026quot; + \u0026quot;world\u0026quot; 错误，其 + 两边都为字符串字面值。\n字符串字面值 和 string 是不同的类型。\n处理 string 对象中的字符 C++ 修改了 c 的标准库 ctype.h 为 cctype，其中定义了一组标准函数：\n函数 解释 isalnum(c) 当c是字母或数字时为真 isalpha(c) 当c是字母时为真 iscntrl(c) 当c是控制字符时为真 isdigit(c) 当c是数字时为真 isgraph(c) 当c不是空格但可以打印时为真 islower(c) 当c是小写字母时为真 isprint(c) 当c是可打印字符时为真 ispunct(c) 当c是标点符号时为真 isspace(c) 当c是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） isupper(c) 当c是大写字母时为真 isxdigit(c) 当c是十六进制数字时为真 tolower(c) 当c是大写字母，输出对应的小写字母；否则原样输出c toupper(c) 当c是小写字母，输出对应的大写字母；否则原样输出c 遍历字符串：\n1 2 3 for (auto c : str) { ... } str[idx] 中的 idx 为 string::size_type 类型，如果使用 int 会隐式转换为该类型。\n标准库类型 vector 标准库类型 vector 表示对象的集合，其中给所有对象的类型都相同。因为 vector 容纳着其他对象，所以称其为 容器（container），使用 vector 必须包含其头文件：\n1 2 3 #include \u0026lt;vector\u0026gt; using std::vector vector 同时也是 类模板（class template），模板本身不是类或函数，但可以使用模板创建类，这个过程称为 实例化（instantiation）。\n当使用模板时，需要指出编译器应把类或函数实例化成何种类型：\n1 2 vector\u0026lt;int\u0026gt; ls; // ls 保存 int 类型的对象 vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; files; // 该向量中的元素是 vector 对象 vector 是模板，vector\u0026lt;int\u0026gt; 是类型。\n定义和初始化 vector 对象 初始化vector对象的方法：\n方法 解释 vector\u0026lt;T\u0026gt; v1 v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 vector\u0026lt;T\u0026gt; v2(v1) v2中包含有v1所有元素的副本 vector\u0026lt;T\u0026gt; v2 = v1 等价于v2(v1)，v2中包含v1所有元素的副本 vector\u0026lt;T\u0026gt; v3(n, val) v3包含了n个重复的元素，每个元素的值都是val vector\u0026lt;T\u0026gt; v4(n) v4包含了n个重复地执行了值初始化的对象 vector\u0026lt;T\u0026gt; v5{a, b, c...} v5包含了初始值个数的元素，每个元素被赋予相应的初始值 vector\u0026lt;T\u0026gt; v5={a, b, c...} 等价于v5{a, b, c...} vector 对象的操作： vector支持的操作：\n操作 解释 v.emtpy() 如果v不含有任何元素，返回真；否则返回假 v.size() 返回v中元素的个数 v.push_back(t) 向v的尾端添加一个值为t的元素 v[n] 返回v中第n个位置上元素的引用 v1 = v2 用v2中的元素拷贝替换v1中的元素 v1 = {a,b,c...} 用列表中元素的拷贝替换v1中的元素 v1 == v2 v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 同上 \u0026lt;,\u0026lt;=,\u0026gt;, \u0026gt;= 以字典顺序进行比较 迭代器介绍 除了下标运算符外，迭代器（iterator） 也可以访问对象中的元素，所有标准库的容器都支持迭代器。类似于指针类型，迭代器也提供了对对象的间接访问。\n使用迭代器 拥有迭代器的类型都具有 begin 和 end 成员，其中 begin 成员返回指向第一个元素的迭代器：\n1 2 vector\u0026lt;int\u0026gt; ls{1, 2, 3}; auto b = v.begin(), e = v.end(); // b 和 e 类型相同 end 成员返回指向容器“尾元素的下一个位置（one past the end）”的迭代器，即 end 指向容器的 尾后（off the end） 元素。这样的迭代器通常没有意义，只是作为标记，被称为 尾后迭代器（off-the-end iterator） 或 尾迭代器（end iterator）。\n若容器为空，则 begin 和 end 都返回尾后迭代器。\n标准容器迭代器的运算符:\n运算符 解释 *iter 返回迭代器iter所指向的元素的引用 iter-\u0026gt;mem 等价于(*iter).mem ++iter 令iter指示容器中的下一个元素 --iter 令iter指示容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等 泛型编程：尽量使用 != 来对迭代器进行判断\n迭代器也拥有自己的类型：\n1 2 vector\u0026lt;int\u0026gt;::iterator it; // it 是 vector\u0026lt;int\u0026gt; 类型的迭代器，可以读写元素 vector\u0026lt;int\u0026gt;::const_iterator it2; // it2 只能读，不能写 如果容器中的值为常量，则 begin 和 end 返回 const_iterator，否则返回 iterator。\n解引用和成员访问：解引用迭代器可以获得迭代器所指的对象，如果该对象是一个类，则可以进一步访问其成员：\n1 2 3 4 5 6 vector\u0026lt;string\u0026gt; ls{\u0026#34;str1\u0026#34;, \u0026#34;str2\u0026#34;}; auto it = ls.begin(); string s = *it; // s 为 \u0026#34;str1\u0026#34; bool flag = (*it).empty(); // 解引用访问 string 成员 bool flag = it-\u0026gt;empty(); // 作用同上 迭代器运算 string 和 vector 的迭代器提供了额外的运算符，支持迭代器的关系运算和跨过多个元素，这些运算称为 迭代器运算（iterator arithmetic）：\n运算符 解释 iter + n 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter - n 迭代器减去一个整数仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 iter1 += n 迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1 iter1 -= n 迭代器减法的复合赋值语句，将iter2减n的加过赋给iter1 iter1 - iter2 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 \u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;= 迭代器的关系运算符，如果某迭代器 当两个迭代器指向同一个容器时，它们可以进行加减操作得到距离，这个距离的类型为 difference_type 类型，是带符号整数型。\n数组 数组可以看做 vector 的低配版，其 长度固定。\n定义和初始化内置数组 数组的声明和定义形如 a[d]，其中 a 是数组的名字，d 是数组的维度（大于 0）：\n1 2 3 4 5 6 7 8 int cnt = 42; // 非常量 const int cnt2 = 42; // 常量 int arr[10]; // 含有 10 个整数的数组 int *arr2[10]; // 含有 10 个整型指针的数组 int arr3[cnt]; // 报错，cnt 非常量 int arr4[cnt2]; // 含有 42 和整数的数组 int arr5[] = {1, 2, 3}; // 自动计算长度的数组 字符数组具有一定特殊性，使用字符串初始化字符数组时在结尾处必须增加一个空字符：\n1 2 char arr[] = \u0026#34;hello\u0026#34;; char arr2[5] = \u0026#34;hello\u0026#34;; // 报错，长度不够 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：\n1 2 3 int a[] = {1, 2, 3}; int a2[] = a; // 报错，不能用数组来初始化数组 a2 = a; // 报错，不能用数组进行赋值 访问数组元素 数组的下标为 size_t 类型，是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。\n下标存在越界导致缓冲区溢出等情况，这种情况需要程序员自行检查。\n指针和数组 使用数组时，编译器会将其转换成指针。使用取地址符可以获取数组的元素的指针，如果是取数组的指针，则默认返回数组第一个元素的指针：\n1 2 3 int ls[] = {1, 2, 3} int *p = \u0026amp;ls[0]; // 数组的元素的指针 int *p2 = ls; // 等价于 *p2 = \u0026amp;ls[0] C 风格字符串 字符串字面值是一种通用结构的实例，这种结构是 C++ 由 C 继承而来的 C 风格字符串（C-style character string） 。 按此习惯书写的字符串存放在字符数组中并以 空字符结束（null terminated）。\n在 C++ 程序中尽量不要使用 C 风格字符串，容易引起安全漏洞且不方便。\nC标准库String函数，定义在\u0026lt;cstring\u0026gt; 中：\n函数 介绍 strlen(p) 返回p的长度，空字符不计算在内 strcmp(p1, p2) 比较p1和p2的相等性。如果p1==p2，返回0；如果p1\u0026gt;p2，返回一个正值；如果p1\u0026lt;p2，返回一个负值。 strcat(p1, p2) 将p2附加到p1之后，返回p1 strcpy(p1, p2) 将p2拷贝给p1，返回p1 多维数组 严格来说，C++ 语言中没有多维数组，所谓的多维数组实际是数组的数组。\n1 int arr[10][20] = {0}; // 长度为 10 的数组，其中每个元素是长度为 20 的数组，且都初始化为 0 使用范围 for 语句处理多维数组 1 2 3 4 5 6 7 size_t cnt = 0; for (auto \u0026amp;row: arr) { for (auto \u0026amp;col: row) { col = cnt; cnt ++; } } ","date":"2023-11-14T22:14:23+08:00","image":"https://3000ye.com/p/c-primer-ch03/assets/c++primer_hu_d7e9cfb8d681b79f.jpg","permalink":"https://3000ye.com/p/c-primer-ch03/","title":"C++ Primer Ch03"},{"content":"变量和基本类型 变量提供一个具名的、可供程序操作的存储空间。C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。\n变量的声明和定义 为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate complication） 机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。\n为了支持分离式编译，C++语言将声明和定义区分开来。声明（declaration） 使得名字为程序所致，一个文件如果想使用别处定义的的名字则必须包含对那个名字的声明。而 定义（definition） 负责创建与名字关联的实体。\n变量声明规定了变量的类型和名字，定义在此基础上，还申请存储空间，甚至可能会为变量赋一个初始值。\n1 2 3 4 extern int i; // 声明 int i; // 定义 int i = 3; // 定义并赋值 extern int i = 3; // 定义而非声明，extern失效 注意： 变量只能被定义一次，但可以被多次声明。因此在多个文件中使用同一个变量名时，需要多次声明，但只能有且仅在一个文件中定义。\n标识符 C++的 标识符（identifier） 由字母、数字和下划线组成，其中必须以字母或下划线开头，没有长度限制，但对大小写敏感。\n作用域 作用域（scope） 是程序的一部分，在其中名字有特定的含义，C++语言中大多数作用域都以花括号分隔。\n作用域能彼此包含，被包含（嵌套）的作用域称为 内层作用域（inner scope），包含着别的作用域的作用域称为 外层作用域（outer scope）。作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字，同时允许在内层作用域中重新定义外层作用域已有的名字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;iostream\u0026#34; int outer = 42; // 全局作用域 int main() { int inner = 12; // 内层作用域 // 使用全局变量输出 std::cout \u0026lt;\u0026lt; outer \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; inner \u0026lt;\u0026lt; std::endl; int outer = 0; // 局部重新定义，覆盖全局变量 // 使用局部变量输出 std::cout \u0026lt;\u0026lt; outer \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; inner \u0026lt;\u0026lt; std::endl; // 显式访问全局变量 std::cout \u0026lt;\u0026lt; ::outer \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; inner \u0026lt;\u0026lt; std::endl; return 0; } 复合类型 复合类型（compound type） 是指基于其他类型定义的类型，主要介绍引用和指针。\n引用 引用（reference） 为对象起了另外一个名字，定义引用时，程序把引用和它的初始值 绑定（bind） 在一起，而不是将初始者拷贝给引用。\n引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026#34;iostream\u0026#34; int main() { int x = 3; // 定义 int \u0026amp;y = x; // 引用 int z = x; // 定义 y = 3; // 修改 y 的值，实际是修改 x 的值 std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; return 0; } 指针 指针（pointer） 是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但指针还有很多不同点：\n指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值，和其他内置类型一样，没有赋初值时将拥有一个不确定值。 1 2 int *ip1, *ip2; // ip1 和 ip2 都是指向 int 类型对象的指针 double dp, *dp2; // dp2 是指向 double 类型对象的指针，dp 是 double 类型对象 指针存放某个对象的地址，想获取该地址，需要使用 取地址符（\u0026amp;）：\n1 2 int val = 42; int *p = \u0026amp;val; // p 存放变量 val 的地址，或者说 p 是指向变量 val 的指针 因为引用不是对象，没有实际地址，因此不能定义指向引用的指针。\n指针的值（即地址）应属于下列 4 种状态之一：\n指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针，意味着指针没有指向任何对象。 无效指针，也就是上述情况之外的其他值。 如果指针指向了一个对象，则允许使用 解引用符（*） 来访问该对象：\n1 2 3 4 int val = 42; int *p = \u0026amp;val; std::cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; std::endl; // 由符号 * 得到指针 p 所指的对象，输出 42 解引用操作仅适用于有效指针，无效指针无法解引用。\n空指针（null pointer） 不指向任何对象，在试图使用一个指针之前代码可以先检查其是否为空。\n生成空指针：\n1 2 int *p1 = nullptr; // 等价于 int *p1 = 0 int *p2 = 0; 指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中引用本身并非是一个对象。定义引用之后，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。\n指针没有这种限制，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。\n1 2 3 4 5 6 7 int i = 42; int *pi = 0; // pi 为空指针 int *pi2 = \u0026amp;i; // pi2 存放 i 的地址 int *pi3; // pi3 的值无法确定 pi3 = pi2; // pi3 和 pi2 指向同一个对象 i pi2 = 0; // pi2 变为空指针 const 限定符 有时我们想定义这样一种变量，它的值不能被改变，这在程序运行过程中对于某些特定值非常有用。为了满足这一要求，可以使用关键字const对变量的类型加以限定：\n1 const int bufferSize = 512; // 限定缓冲区大小为 512 默认情况下，const对象被设定为仅在单个文件内有效。当多个文件中出现了同名的const变量时，其等同于在多个文件中分别定义了独立的变量。但当我们需要其在多个文件中保持一致时，需要在定义和声明前面都加上extern：\n1 2 3 4 5 // 定义文件 xxx.cpp extern const int bufferSize = 512; // 声明文件 xxx.hpp extern const int bufferSize; 指针和 const 与引用一样，也可以令指针指向常量与非常量。指向常量的指针（pointer to const） 不能用于改变其所指对象的值。要想存放常量对象的地址，必须使用指向常量的指针：\n1 2 3 4 5 const int val = 42; // val 为常量对像，其值不能改变 int *pi = \u0026amp;val; // 报错，pi 为普通指针，不能存放常量对象地址 const int *pi2 = \u0026amp;val; // 使用指向常量的指针存放常量对象地址 *pi2 = 20; // 报错，不能给指向常量的指针赋值 处理类型 随着程序越来越复杂，其中使用的变量类型也越复杂，如何处理这些类型成为一个问题。\n类型别名 类型别名（type alias） 是一个名字，它是某种类型的同义词。\n使用关键字typedef定义类型别名：\n1 typedef long long ll; // ll 是 long long 的同义词 使用 别名声明（alias declaration） 定义类型别名：\n1 using ll = long long; // ll 是 long long 的同义词 auto 类型说明符 编程时常常需要将表达式的结果赋给变量，这就要求需要事先知道结果的类型。但是要做到这一点有时并不容易，因此C++11引入了auto类型说明符，它能自动分析表达式结果的类型。\n1 auto item = val1 + val2; // item 初始化为 val1 和 val2 相加的结果 使用auto定义或声明多个变量时，所有变量的类型必须一致：\n1 2 auto x = 3, y = 5; auto x = 3, y = 4.2; // 报错，同一行的变量类型必须一致 decltype 类型指示符 有时会遇到这种情况：希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量——即只使用表达式的数据类型，不使用表达式的结果。\n因此C++11引入了decltype类型指示符，它的作用是返回操作数的数据类型：\n1 2 int x = 5, y = 7; decltype(x + y) z = 6; // z 为 int 类型 自定义数据结构 内置的数据类型并不能满足所有的需求，因此c++提供了自定义数据类型的方式：\n1 2 3 4 5 6 7 8 9 10 11 struct student { std::string name; std::string sex; int gender; }; // 定义 student jack{\u0026#34;jack\u0026#34;, \u0026#34;m\u0026#34;, 18}; // 先声明后赋值 student castor; castor.name = \u0026#34;castor\u0026#34;, castor.sex = \u0026#34;m\u0026#34;, castor.gender = 18; 自定义数据结构使用别名 和内置数据类型一样，自定义数据结构也能使用别名：\n1 2 3 4 5 6 7 8 using stu = studeng; // 或直接在定义时使用别名 using stu = struct student { std::string name; std::string sex; int gender; }; 编写自己的头文件 当我们在编写头文件时，会引入其他头文件，而在生产文件中，又会再次引入这些头文件。这样就导致一个问题，某些头文件被重复引入了。因此，在编写头文件时需要做一定的保护措施：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // studeng.h #ifndef STUDENT_H #define STUDENT_H #include \u0026#34;string\u0026#34; struct student { std::string name; std::string sex; int gender; }; #endif ","date":"2023-11-06T22:34:55+08:00","image":"https://3000ye.com/p/c-primer-ch02/assets/c++primer_hu_d7e9cfb8d681b79f.jpg","permalink":"https://3000ye.com/p/c-primer-ch02/","title":"C++ Primer Ch02"},{"content":"使用 $\\LaTeX$ 绘制 Slides ","date":"2023-10-20T10:04:55+08:00","image":"https://3000ye.com/p/slides/assets/latex_hu_845ccbc3e81fb8a3.jpg","permalink":"https://3000ye.com/p/slides/","title":"Slides"},{"content":"东华大学学士毕业论文 LaTeX 模板使用手册 导入模板 使用 Git 克隆仓库 将仓库克隆到你需要的位置：\n1 2 3 git clone git@github.com:3000ye/dhuBachelor.git # 或 git clone https://github.com/3000ye/dhuBachelor.git 下载 Zip 文件 如果你不会使用Git，可以进入网页：https://github.com/3000ye/dhuBachelor 然后下载Zip文件：\n微信公众号获取 如果你没有科学代理，无法进入Github，请扫码关注公众号：3000ye Blog然后回复latex模板获取百度网盘分享链接。\n开始使用 安装字体 在使用模板之前，请先找到并打开fonts文件夹，安装里面的所有字体。\n配置 TeX 环境 如果你是 $\\LaTeX$ 小白，请先行阅读：使用 LaTeX 优雅地完成创作，在这个教程里你可以学会如何安装并配置适合你的 $\\TeX$ 环境。\n尝试编译 使用你喜欢的编辑器，打开dhuBachelor.tex文件，选择xelatex命令编译文件。如果没有出现报错，同目录下会生成一个dhuBachelor.pdf文件，这就是我们的论文。\n各个组件说明 看到这里，相信你已经成功编译好了模板文件，现在你可以在其基础上创作你的论文。\n本模板的格式严格按照东华大学本科生毕业设计（论文）撰写规范设置，下面是一些会用到的组件的详细说明。\n论文题目 根据要求，论文题目使用三号黑体，上下各空一行，居中显示。添加代码：\n1 2 \\reTitle{中文题目} \\reTitleEN{英文题目} 摘要 根据要求，摘要使用四号黑体，下面空一行，居中显示。添加代码：\n1 2 \\reAbstract % 中文摘要 \\reAbstractEN % 英文摘要 摘要内容直接写在摘要下方，首行缩进两字符。\n关键词 中文关键词：小四号黑体（标题），小四号宋体（关键词），逗号分隔，末尾没有标点符号。\n英文关键词：Times New Roman（标题加黑）。\n1 2 \\reKeyword{关键词1，关键词2，关键词3，关键词4} % 中文关键词 \\reKeywordEN{Keyword1, Keyword2, Keyword3} % 英文关键词 目录 目录标题需居中显示，添加代码：\n1 2 3 \\begin{center} \\tableofcontents \\end{center} 各级标题 规范中明确给出，最多只能使用三级标题，其中一级标题需上下各空一行。\n1 2 3 \\reSection{一级标题} \\subsection{二级标题} \\subsubsection{三级标题} 有序列表 规范中并没有给出无序列表的样例，因此不建议使用，只用有序列表：\n1 2 3 4 5 6 7 \\orderedList{ % 使用 (i) 排序，缩进 2 字符 \\item 有序列表标题 \\par % \\par的作用是将内容换行 这是有序列表的内容 \\item 有序列表标题 \\par 这是有序列表的内容 } 数学公式 行内公式：$f(x) = x + 1$\n跨行公式：跨行公式请使用equation环境，默认按照章节自动编号。\n1 2 3 4 5 \\begin{equation} x = a_0 + \\cfrac{1}{a_1 + \\cfrac{1}{a_2 + \\cfrac{1}{a_3 + \\cfrac{1}{a_4} } } } \\end{equation} 插入图片 图片插入默认在文字下方，请严格按照模板的格式进行插入，使用时只需要改width大小和图片路径，并根据实际更改图例和索引。\n注意：图片需要保存在assets/目录中才能被正确插入，读者可以自己新建其他目录实现插入。\n1 2 3 4 5 6 7 \\begin{figure}[H] % 图片位于文字下方 \\centering % 居中 % 设置图片占页面宽度的比例（默认0.8） \\includegraphics[width=0.8\\textwidth]{assets/dataStructures.jpg} \\caption{图片标题} % 图例，按章节编号 \\label{fig: 数据结构2} % 图片索引 \\end{figure} 有时可能需要多图并排，模板使用minipage来实现并排展示，使用时可以修改子图所占比例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \\begin{figure}[H] \\centering \\begin{minipage}[c]{0.40\\textwidth} %minipage使之保持同一行 \\centering \\includegraphics[width=0.8\\textwidth]{assets/dataStructures.jpg}\\\\ \\caption{图片1标题} \\end{minipage} \\hspace{1em} \\begin{minipage}[c]{0.40\\textwidth} %minipage使之保持同一行 \\centering \\includegraphics[width=0.8\\textwidth]{assets/dataStructures.jpg}\\\\ \\caption{图片2标题} \\end{minipage} \\end{figure} 插入表格 使用 excel2latex 工具生成表格代码后，需要手动添加分割线（\\toprule, \\midrule, \\bottomrule），以达到三线表的格式要求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \\begin{table}[H] \\centering \\caption{表格标题} \\begin{tabular}{c||l} \\toprule parameter \u0026amp; Description \\\\ \\midrule $I$ \u0026amp; Land area collection \\\\ $J$ \u0026amp; Flower pollination demand set \\\\ $D_j$ \u0026amp; Number of pollinating bees required for flower pollination \\\\ $T_k$ \u0026amp; Honeycomb size grade, $k = 1, 2, \\cdots$ \\\\ $B$ \u0026amp; Maximum number of hive \\\\ $R_{ik}$ \u0026amp; Maximum influence radius of a single honeycomb \\\\ \\bottomrule \\end{tabular}% \\label{tab: 一个表}% \\end{table}% 对于需要多表并排的情况，和图片的方式类似，使用minipage来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \\begin{minipage}[c]{0.45\\textwidth} \\centering \\begin{table}[H] \\centering \\caption{表格1标题} \\begin{tabular}{c||lc} \\toprule Symbol \u0026amp; Description \u0026amp; Unit \\\\ \\midrule $t$ \u0026amp; $t_{th}$ year \u0026amp; $\\sim$ \\\\ $e_k$ \u0026amp; the error term \u0026amp; $\\sim$ \\\\ $X_{ij}$ \u0026amp; Raw data matrix \u0026amp; $\\sim$ \\\\ $Y_{ij}$ \u0026amp; Positive matrix \u0026amp; $\\sim$ \\\\ \\bottomrule \\end{tabular}% \\label{tab: 表格1标题}% \\end{table}% \\end{minipage} \\begin{minipage}[c]{0.45\\textwidth} \\centering \\begin{table}[H] \\centering \\caption{表格2标题} \\begin{tabular}{c||lc} \\toprule Symbol \u0026amp; Description \u0026amp; Unit \\\\ \\midrule $t$ \u0026amp; $t_{th}$ year \u0026amp; $\\sim$ \\\\ $e_k$ \u0026amp; the error term \u0026amp; $\\sim$ \\\\ $X_{ij}$ \u0026amp; Raw data matrix \u0026amp; $\\sim$ \\\\ $Y_{ij}$ \u0026amp; Positive matrix \u0026amp; $\\sim$ \\\\ \\bottomrule \\end{tabular}% \\label{tab: 表格2标题}% \\end{table}% \\end{minipage} 插入代码 可以直接在.tex文件中编写代码，并指定语言和标题：\n1 2 3 4 5 6 7 8 9 10 11 \\begin{lstlisting}[language=c++,title={code.cpp}] #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;3000ye 的 LaTeX 模板！\u0026#34; \u0026lt;\u0026lt; endl; return 0; } \\end{lstlisting} 另一种更为推荐的方式是加载文件中的代码，代码文件需要保存在assets/目录下：\n1 \\lstinputlisting[language=c++, title=code.cpp]{code/code.cpp} 插入伪代码 使用宏包algorithm, algorithmic来实现伪代码的添加，具体实现可以查看文档，下面是一个简单示例：\n1 2 3 4 5 6 7 8 9 10 11 \\begin{algorithm} \\caption{Example Pseudocode} \\begin{algorithmic} \\STATE $x\\gets0$ \\IF {$x\\leq 0$} \\STATE $x\\gets x+1$ \\ELSE \\STATE $x\\gets x-1$ \\ENDIF \\end{algorithmic} \\end{algorithm} 参考文献 参考文献使用\\bibitem来添加，添加时需要手动更改{RNi}索引（i是你文献的序号）。\n1 2 3 4 \\reference{ \\bibitem{RN1} 参考文献1 \\bibitem{RN2} 参考文献2 } 致谢 1 2 3 \\reThanks{ 致谢，3000ye 的 \\LaTeX 模板！ } ","date":"2023-10-12T16:41:55+08:00","image":"https://3000ye.com/p/dhubachelor/assets/latex_hu_845ccbc3e81fb8a3.jpg","permalink":"https://3000ye.com/p/dhubachelor/","title":"dhuBachelor"},{"content":"使用 $\\LaTeX$ 优雅地完成创作 $\\LaTeX$ 是一个文档准备系统 (Document Preparing System)，它非常适用于生成高印刷质量的科技类和数学类文档。它也能够生成所有其他种类的文档，小到简单的信件，大到完整的书籍。 $\\LaTeX$ 使用 $\\TeX$ 作为它的排版引擎，学习 $\\LaTeX$ 是一个漫长而痛苦的过程，我们应该充分利用已知的资料，来尽量完成我们的需求。\n从安装 $\\TeX$ 引擎开始 $\\TeX$ 引擎类似于 gcc/g++ 或 Python，用于编译 $\\LaTeX$ 文档。\n不同平台中 $\\TeX$ 的安装方法不尽相同，本文提供：Windows11、Linux(Ubuntu 22.04)、MacOs(12.7)、Windows11-wsl2(Ubuntu22.04)的安装方法。\n如果你只是想简单体验 $\\LaTeX$，可以使用 overleaf 在线编译平台。但出于环境稳定性和数据的安全性等因素，并不建议将其作为主力平台。\nWindows11 进入网站tug.org for windows，点击install-tl-windows.exe下载 $\\TeX$ 安装器，然后运行安装即可。\n不过，这种方法需要一直联网安装，网速不好的环境可以直接下载iso镜像进行本地安装。本文给出清华源镜像地址：mirrors.tuna，下载后缀为.iso的文件（只用下载一个）。\n下载完成后双击文件挂载镜像，然后打开镜像文件夹，右键点击install-tl-windows.bat文件，使用管理员打开，然后按照指引安装即可。\n最新版本的安装器会自动添加环境变量，安装完成后打开cmd然后输入：\n1 tex --version 若能输出 $\\TeX$ 版本信息则安装成功：\n1 2 3 TeX 3.141592653 (TeX Live 2023/W32TeX) kpathsea version 6.3.5 Copyright 2023 D.E. Knuth. Linux(Ubuntu22.04) 打开终端，然后执行安装命令：\n1 2 3 sudo apt update sudo apt upgrade sudo apt install texlive-full 等待安装完成即可，安装完成后执行命令：\n1 tex --version 若能输出 $\\TeX$ 版本信息则安装成功：\n1 2 3 TeX 3.141592653 (TeX Live 2023/Debian) kpathsea version 6.3.5 Copyright 2023 D.E. Knuth. MacOs(12.7) 打开终端，然后执行安装命令（推荐安装无窗体版本）：\n1 brew install mactex-no-gui 等待安装完成即可，安装完成后执行命令：\n1 tex --version 若能输出 $\\TeX$ 版本信息则安装成功：\n1 2 3 TeX 3.141592653 (TeX Live 2023) kpathsea version 6.3.5 Copyright 2023 D.E. Knuth. Windows11-wsl2(Ubuntu22.04) 在wsl2中安装方式与在Linux中一样。\n找到属于你的编辑器 市面上有很多 $\\LaTeX$ 编辑器，且与使用的系统有关，下面是一些主观评价：\n全平台通用： Vs Code：作为地表最强编辑器，Vs Code拥有非常丰富的 $\\LaTeX$ 插件和完备的配置方案，并且可以免费使用，但缺点是配置较为繁琐。 Jetbrains: 与Vs Code相对应的是Jetbrains系列， 其虽然也有 $\\LaTeX$ 插件，但使用体验非常不好，且其文件管理方式并不适合每个人。 Neovim：如果说Vs Code是编辑器中的王后，那么nvim就是国王。nvim可以实现最大程度的自定义编辑方案，拥有海量插件生态，但缺点是学习路线非常陡峭，常人难以驾驭。 sublime text：nvim固然强大，但其难以上手的特点使得很多人对其望而却步。sublime打破了这个束缚，其界面优雅程度不亚于nvim，也具有丰富的插件来实现你的理想配置，但配置同样较为繁琐，且需要付费。 TexStudio：texlive默认自带编辑器，简单好用容易上手，是很多教程的主推编辑器，但笔者认为界面过于丑陋，不建议用。 Windows独占： Winedt 11：如果不考虑跨平台，那么Winedt 11就是Windows上的最佳编辑器。这是一款罕见的非所见即所得的编辑器，笔者认为这完美契合了 $\\LaTeX$ 的风格，同时其优雅成熟的界面和高度可定制化的功能使其一骑绝尘。但需要付费（169元买断）。 综上所述，笔者最推荐Vs Code，但如果你只有Windows平台的使用需求并不介意一点费用的话，请果断购买Winedt 11。同样的，MacOs也拥有独占编辑器，但笔者没用过，在此不做评价。\n关于这些编辑器如何配置，网上的教程有很多，读者可自行查阅。\n一本教程入门 $\\LaTeX$ 语法 对于所有初学者来说，Ishort-zh-cn都是最好的入门教程。在开始你的创作之前，请务必先行完整阅读一遍，并动手尝试书中的案例。\n如果你已经完成了所有的案例，相信你已经对 $\\LaTeX$ 语法有了简单了解，下面笔者给出一些新手可能遇到的常见问题。但请不要灰心，$\\LaTeX$ 的学习是一件持久且困难的事，我们并不需要完全精通，只需要能够达到创作目的即可。\n打印中文 $\\LaTeX$ 默认只打印英文，如果没有合理的设置，.tex文件中的中文将无法正确打印。\n从下图可以看出，目前支持全平台通用的方案只有XeLaTeX和LuaTeX。因此，主流方案是一般使用xelatex+ctex编译方案，底层调用xeCJK字符集来实现中文打印。\n使用时只需在导言区加入，编译器会使用默认字体进行编译：\n1 2 \\usepackage[UTF8]{ctex} \\usepackage{fontspec} % 设置字体 如果要指定字体，则需分别设置font-family：\n1 2 3 4 5 \\usepackage[UTF8, fontset=none]{ctex} % 清除默认字体 \\usepackage{fontspec} % 设置字体 \\setCJKmainfont{SimSun}[AutoFakeBold=true, BoldFont={SimHei}, ItalicFont={KaiTi}] % 正文字体（宋体，黑体，楷体） \\setCJKsansfont[AutoFakeBold=3]{KaiTi} % 无衬线字体 \\setCJKmonofont[AutoFakeBold=3]{SimHei} % 等宽字体 同样的，英文也可以自定义字体：\n1 \\setmainfont{Times New Roman} % 设置英文字体为新罗马体 详细配置可以参考：LaTex 中文字体配置指南\n打印数学公式 你是否好奇过数学教材或者论文中复杂的数学公式是如何编写的？答案就是 $\\LaTeX$，这也是 $\\LaTeX$ 为什么被奉为珍宝的原因之一。\n但是笔者并不建议读者专门花时间来学习如何编写 $\\LaTeX$ 数学公式，而是利用现成的工具来快速完成你的公式。\n在线数学公式生成平台：latexlive可以在线点击生成你所需要的数学公式，但前提是你已经了解了一些复杂数学环境。 MathType：如果你是Windows用户，那么强烈建议使用MathType来生成数学公式的 $\\LaTeX$ 代码，好处是完全不需要代码基础并且功能十分强大，但是需要付费。 mathpix：这是一款专为 $\\LaTeX$ 打造的数学公式 OCR 识别器，你可以截屏、拍照、甚至手写数学公式来得到你想要的代码。 绘制表格 你一定使用过Excel来绘制表格，但是在 $\\LaTeX$ 中绘制表格并不是一件轻松的事情，其中有非常多的坑且几乎每个人都无法避免。\n但不用担心，本文为你介绍开源项目 excel2latex。这是一款Excel插件，可以将你在Excel中绘制的表格自动转译为 $\\LaTeX$ 代码。\n但是这个插件并不是万能的，比如绘制三线表，即使是在Excel中也较为繁琐。因此，最好的处理方式是使用excel2latex插件生成表格主体，然后再自己添加分隔格式。\n插入图片 绘制表格和插入图片并称为 $\\LaTeX$ 中两大天坑，对于图片插入笔者尚未发现有效替代工具，在下文中会给出一些示例代码供读者参考。\n学会使用代码片段 阅读到这里，相信你已经能够使用 $\\LaTeX$ 创作出你自己的内容了。那么你应该不难发现，在创作的时候有很多代码都是可以重复使用的，只需要更改一些参数即可。但是 $\\LaTeX$ 并不能像编程语言那样编写函数来实现代码的复用，当然有其他方法来实现（比如编写.sty和.cls文件），但这对初学者来说太难了。\n因此，有没有一种好的方法可以实现这个需求呢？答案是代码片段（code snippets）。\n代码片段可以给你的编辑器添加些许魔力。它如同咒语一般。你只要说出指令（输入前缀），挥动魔杖（按下 Enter 或者 Tab 键），然后神奇的事情就发生在你眼前了。\nVs Code配置代码片段 点击左下角的设置按钮，然后点击设置用户代码片段：\n在弹出的窗口中输入latex然后选中即可跳转到latex.json文件，我们可以在这里设置我们的代码片段。\n比如这段设置，保存文件后我们只需要在.tex后缀的文件中输入insertImg然后回车就会自动填充以下代码，并且使用tab来依次输入参数。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026#34;insertImg\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;insertImg\u0026#34;, // 代码片段别名 \u0026#34;body\u0026#34;: [ // 代码片段主体 \u0026#34;\\\\begin{figure}[H]\u0026#34;, \u0026#34; \\\\centering\u0026#34;, \u0026#34; \\\\includegraphics[width=0.8\\\\textwidth]{$1}\u0026#34;, // 参数1：图片路径 \u0026#34; \\\\caption{$2}\u0026#34;, // 参数2：图片标题 \u0026#34; \\\\label{$3}\u0026#34;, // 参数3：图片索引 \u0026#34;\\\\end{figure}$0\u0026#34;, ], \u0026#34;description\u0026#34;: \u0026#34;insert one img with 0.8 width\u0026#34; }, Winedt 设置代码片段 依次点击Option -\u0026gt; Options Interface -\u0026gt; Menus and Toolbar -\u0026gt; Main Menu，修改或添加配置：\n1 2 3 4 5 6 ITEM=\u0026#34;Figure\u0026#34; CAPTION=\u0026#34;\u0026amp;Figure\u0026#34; IMAGE=\u0026#34;Figure\u0026#34; MACRO=\u0026#34;Exe(\u0026#39;%b\\Menus\\Insert\\Image.edt\u0026#39;);\u0026#34; SHORTCUT=\u0026#34;49222::Ctrl+Alt+F\u0026#34; REQ_DOCUMENT=1 然后就可以使用快捷键Ctrl+Alt+F填充插入图片的代码片段。\n使用模板来专注内容 使用 $\\LaTeX$ 来完成创作时，不同的需求的格式要求通常也不同。一般而言，格式的设置复杂且繁琐，如果将大部分时间花在调整格式上面有违 $\\LaTeX$ 的初衷。\n因此，常见期刊都会提供对应的 $\\LaTeX$ 风格模板和示例，其中主要文件通常为：\n.sty：$\\LaTeX$ 样式文件，包含一组宏包和命令，用于定制文档的样式、格式和功能。通常包括：宏包的引入、自定义命令、颜色与字体预设等。 .cls：$\\LaTeX$ 文档文件，定义文档的整体结构和布局。通常包括：导言区设置、章节标题样式、页眉页脚与文档尺寸预设等。 .tex：示例文件，通常会包括论文中会用到的所有样式的示例代码。 阅读示例文件可以让我们快速创作出符合格式要求的作品，让我们不再为格式烦恼，只用专注于内容本身。\n","date":"2023-10-09T17:18:55+08:00","image":"https://3000ye.com/p/elegant-latex/assets/latex_hu_845ccbc3e81fb8a3.jpg","permalink":"https://3000ye.com/p/elegant-latex/","title":"Elegant LaTeX"},{"content":"由浅到深理解相机标定 何为相机标定 在图像测量过程以及机器视觉应用中，为确定空间无哦表面某点的三维几何位置与其在图像中对应点之间的相互关系，必须建立相机成像的几何模型，这些几何模型参数就是相机参数。\n在大多数条件下这些参数必须通过实验与计算才能得到，这个求解参数的过程就称之为相机标定（或摄像头标定）。\n相机标定涉及的知识面很广：成像几何、镜头畸变、单应矩阵、非线性优化等。\n相机标定有自标定（找图像中特征点）、标定板标定（特征点易求，稳定性好），一般采用标定板标定。\n相机标定按照相机是否静止，可分为静态相机标定（标定板动，相机静止），动态相机标定（标定板静止，相机运动）。\n为什么需要标定 任何理论物理模型都是在特定假设上对真实事物的近似，然而在实际应用中存在误差，普通相机的成像模型也不例外（透视投影）。\n实际中，普通相机成像误差的主要来源有两部分：\n第一是sensor（传感器）制造产生的误差，比如sensor成像单元不是正方形，sensor歪斜。 第二是镜头制造和安装产生的误差，镜头一般存在非线性的径向畸变；镜头与相机sensor安装不平行，还会产生切向畸变。 相机标定的目的和意义 我们所处的世界是三维的，而照片是二维的，这样我们可以把相机认为是一个函数，输入量是一个场景，输出量是一幅灰度图。这个从三维到二维的过程的函数是不可逆的。\n相机标定的目标是我们找一个合适的数学模型，求出这个模型的参数，这样我们能够近似这个三维到二维的过程，使这个三维到二维的过程的函数找到反函数。\n这个逼近的过程就是「相机标定」，我们用简单的数学模型来表达复杂的成像过程，并且求出成像的反过程。标定之后的相机，可以进行三维场景的重建，即深度的感知。\n相关术语 焦点：在几何光学中有时也称为像点，是源头的光线经过物镜后汇聚的点。\n焦距：也称为焦长，是光学系统中衡量光的聚集或发散的度量方式，指从透镜中心到光聚集之焦点的距离。亦是照相机中，从镜片光学中心到底片、CCD或CMOS等成像平面的距离。\n正透镜、负透镜、凹面镜和凸面镜的焦点F和焦距f：\n镜头（Lenses）：是将拍摄景物在传感器上成像的器件，它通常由几片透镜、光圈叶片、对焦马达等光学元件组成。\n传感器（Sensor）：是摄像头组成的核心，其作用是作为相机的感光元件。摄像头传感器主要有两种，一种是CCD传感器，一种是CMOS传感器，两者区别在于：CCD的优势在于成像质量好，但是由于制造工艺复杂，成本居高不下，特别是大型CCD，价格非常高昂。在相同分辨率下，CMOS价格比CCD便宜，但是CMOS器件产生的图像质量相比CCD来说要低一些。\n光心：凸透镜近轴光线中，入射线和与其对应且相平行的出射线构成共轭光线，其入射点跟出射点的连线与主光轴的交点，称为凸透镜的焦点，位于透镜中央的点叫光心。\n从图中可知，O为光心，F为焦点。每个透镜主轴上都有一个特殊点，凡是通过该点的光，其传播方向不变，这个点叫光心。经过光心的光线的传播方向不会发生改变。\n相机标定原理模型 针孔相机模型 我们通常将相机看成如下所示的透镜模型：\n在实际分析时，通常将其简化为针孔模型（小孔成像）：\n一般为了分析简单，将成像平面画在对称位置，这样图像不再颠倒：\n四个坐标系 世界坐标系：用户定义的三维世界的坐标系，用于描述目标物体在真实世界里的位置。单位通常为米（m）。该坐标系作用于三维空间。\n相机坐标系：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。单位通常为米（m）。相机坐标系的原点在光心，其 $X_c、Y_c$ 轴分别与像面的两边平行，其 $Z_c$ 轴与光轴重合，且垂直于图像坐标系平面并通过图像坐标系的原点（实际情况中可能存在主点偏移），相机坐标系与图像坐标系之间的距离为焦距 $f$。该坐标系作用于三维空间。\n图像坐标系：为了描述成像过程中物体从相机坐标系到图像坐标系的投影投射关系而引入，方便进一步得到像素坐标系下的坐标。其原点是相机光轴与像面的交点（称为主点），即图像的中心点。其 $x, y$ 轴和像素坐标系的 $u, v$ 轴平行，故图像坐标系和像素坐标系实际是平移关系。单位通常为毫米（mm）。该坐标系作用于二维空间。\n像素坐标系：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，是我们真正从相机内读取到的信息所在的坐标系。单位为像素。像素坐标平面和图像坐标系平面重合，但像素坐标系原点位于图像左上角。该坐标系作用于二维空间。\n相机外参 将世界坐标系中的点映射到相机坐标系：相机坐标系是世界坐标系通过刚体变换得到的。\n刚体变换能够保持物体中各点的距离和角度，常见的刚体变换有：平移、旋转和镜像。\n我们先只考虑旋转，假设将坐标系以 $X$ 轴为中心进行旋转，即 $X$ 不变，旋转 $Y - Z$ 平面。\n假设旋转角度为 $\\theta$，即 $\\angle Y\u0026rsquo; O Y = \\angle Z\u0026rsquo; O Z = \\theta$。旋转前的坐标系为 $X - Y - Z$，旋转后的坐标系为 $X\u0026rsquo; - Y\u0026rsquo; - Z\u0026rsquo;$。假设点 $P$ 在 $X - Y - Z$ 中的坐标为（$X_w, Y_w, Z_w$），旋转后，其在 $X\u0026rsquo; - Y\u0026rsquo; - Z\u0026rsquo;$ 中的坐标为（$X_c, Y_c, Z_c$）： $$ X_C = X_w $$\n$$ \\begin{array}{l} Y_c \u0026amp; = OC + CD = OA \\cdot \\sin \\theta + BP \\\\ \u0026amp; = Z_w \\cdot \\sin \\theta + AP \\cdot \\cos \\theta \\\\ \u0026amp; = Z_w \\sin \\theta + Y_w \\cos \\theta \\end{array} $$\n$$ \\begin{array}{l} Z_c \u0026amp; = PD = AC - AB \\\\ \u0026amp; = AO \\cdot \\cos \\theta - AP \\cdot \\cos \\theta \\\\ \u0026amp; = Z_w \\cos \\theta + Y_w \\cos \\theta \\end{array} $$\n写成矩阵形式： $$\\displaystyle \\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\end{bmatrix} = \\mathbf{R_{cw}} \\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\end{bmatrix} or \\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\end{bmatrix} = \\mathbf{R_{wc}} \\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\end{bmatrix} $$ 推广到每个方向，可得到 $\\mathbf{R_{cw}}, \\mathbf{R_{wc}}$ 为： $$ \\mathbf{R_{cw}} (X_A, \\theta) = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos \\theta \u0026amp; \\sin \\theta \\\\ 0 \u0026amp; - \\sin \\theta \u0026amp; \\cos \\theta \\end{bmatrix} , \\mathbf{R_{wc}} (X_A, \\theta) = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos \\theta \u0026amp; - \\sin \\theta \\\\ 0 \u0026amp; \\sin \\theta \u0026amp; \\cos \\theta \\end{bmatrix} $$ $$ \\mathbf{R_{cw}} (Y_A, \\theta) = \\begin{bmatrix} \\cos \\theta \u0026amp; 0 \u0026amp; \\sin \\theta \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ - \\sin \\theta \u0026amp; 0 \u0026amp; \\cos \\theta \\end{bmatrix} , \\mathbf{R_{wc}} (Y_A, \\theta) = \\begin{bmatrix} \\cos \\theta \u0026amp; 0 \u0026amp; - \\sin \\theta \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ \\sin \\theta \u0026amp; 0 \u0026amp; \\cos \\theta \\end{bmatrix} $$ $$ \\mathbf{R_{cw}} (Z_A, \\theta) = \\begin{bmatrix} \\cos \\theta \u0026amp; \\sin \\theta \u0026amp; 0 \\\\ - \\sin \\theta \u0026amp; \\cos \\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} , \\mathbf{R_{wc}} (Z_A, \\theta) = \\begin{bmatrix} \\cos \\theta \u0026amp; - \\sin \\theta \u0026amp; 0 \\\\ \\sin \\theta \u0026amp; \\cos \\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$\n这里我们使用右手笛卡尔三维坐标系：\n旋转可分为主动旋转与被动旋转。主动旋转是指将向量逆时针围绕旋转轴所做出的旋转。被动旋转是对坐标轴本身进行的逆时针旋转，它相当于主动旋转的逆操作。关于右手笛卡尔坐标系的 $X, Y, Z$ 轴的旋转分别叫做roll，pitch和yaw旋转：\n因为逆时针和顺时针旋转会得到不一样的旋转矩阵，所以我们统一如下：\n绕 $X$ 轴的主动旋转定义为（$\\theta_x$ 是roll角 ）： $$ R(X_A, \\theta_x) = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos \\theta_x \u0026amp; - \\sin \\theta_x \\\\ 0 \u0026amp; \\sin \\theta_x \u0026amp; \\cos \\theta_x \\end{bmatrix} = \\exp \\left ( \\theta_x \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; -1\\\\ 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\right ) $$ 绕 $Y$ 轴的主动旋转定义为（$\\theta_y$ 是pitch角）： $$ R(Y_A, \\theta_y) = \\begin{bmatrix} \\cos \\theta_y \u0026amp; 0 \u0026amp; \\sin \\theta_y \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ - \\sin \\theta_y \u0026amp; 0 \u0026amp; \\cos \\theta_y \\end{bmatrix} = \\exp \\left ( \\theta_y \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ -1 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} \\right ) $$ 绕 $Z$ 轴的主动旋转定义为（$\\theta_z$ 是yaw角）： $$ R(Z_A, \\theta_z) = \\begin{bmatrix} \\cos \\theta_z \u0026amp; - \\sin \\theta_z \u0026amp; 0 \\\\ \\sin \\theta_z \u0026amp; \\cos \\theta_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} = \\exp \\left ( \\theta_y \\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0\\\\ 1 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} \\right ) $$ 将上述三个旋转矩阵结合起来，最终的旋转矩阵（设绕 $X, Y, Z$ 轴旋转的角度分别为 $\\alpha, \\beta, \\gamma$）： $$ \\begin{array}{ll} M(\\alpha, \\beta, \\gamma) \u0026amp; = R_x(\\alpha) R_y(\\beta) R_z(\\gamma) \\\\ \u0026amp; = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos \\alpha \u0026amp; - \\sin \\alpha \\\\ 0 \u0026amp; \\sin \\alpha \u0026amp; \\cos \\alpha \\end{bmatrix} \\begin{bmatrix} \\cos \\beta \u0026amp; 0 \u0026amp; \\sin \\beta \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ - \\sin \\beta \u0026amp; 0 \u0026amp; \\cos \\beta \\end{bmatrix} \\begin{bmatrix} \\cos \\gamma \u0026amp; -\\sin \\gamma \u0026amp; 0 \\\\ \\sin \\gamma \u0026amp; \\cos \\gamma \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\\\ \u0026amp; = \\begin{bmatrix} \\cos \\gamma \\cos \\beta \u0026amp; - \\sin \\gamma \\cos \\alpha + \\cos \\gamma \\sin \\beta \\sin \\alpha \u0026amp; \\sin \\gamma \\sin \\alpha + \\cos \\gamma \\sin \\beta \\cos \\alpha \\\\ \\sin \\gamma \\cos \\beta \u0026amp; \\cos \\gamma \\cos \\alpha + \\sin \\gamma \\sin \\beta \\sin \\alpha \u0026amp; - \\cos \\gamma \\sin \\alpha + \\sin \\gamma \\sin \\beta \\cos \\alpha \\\\ - \\sin \\beta \u0026amp; \\cos \\beta \\sin \\alpha \u0026amp; \\cos \\beta \\cos \\alpha \\end{bmatrix} \\end{array} $$\n此时我们再加上平移向量 $T$ 便可完成从世界坐标系到相机坐标系的这个刚体变换了：\n$$ \\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\end{bmatrix} = \\begin{bmatrix} r_{11} \u0026amp; r_{12} \u0026amp; r_{13} \\\\ r_{21} \u0026amp; r_{22} \u0026amp; r_{23} \\\\ r_{31} \u0026amp; r_{32} \u0026amp; r_{33} \\end{bmatrix} \\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\end{bmatrix} + \\begin{bmatrix} t_x \\\\ t_y \\\\ t_z \\end{bmatrix} = \\mathbf{R} \\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\end{bmatrix} + T $$\n可进一步写成如下形式：\n$$ \\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\mathbf{R} \u0026amp; \\mathbf{T} \\\\ 0_3^T \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\\\ 1 \\end{bmatrix} $$\n其中，$\\mathbf{R}$ 和 $\\mathbf{T}$ 便是相机外参。\n相机内参 首先考虑图像坐标系（$xy$）和像素坐标系（$uv$）之间的转换：\n$$ \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} \\displaystyle \\frac{1}{dx} \u0026amp; 0 \u0026amp; u_0 \\\\ 0 \u0026amp; \\displaystyle \\frac{1}{dy} \u0026amp; v_0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}= \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} $$\n$dx$ 表示一个像素点在 $x$ 方向的长度是多少毫米，$dy$ 表示一个像素点在 $y$ 方向的长度是多少毫米；$(u_0, v_0)$ 为图像的中心点。\n然后考虑相机坐标系和图像坐标系之间的转换：\n$$ \\Delta ABO_c \\sim \\Delta oCO_c, \\Delta PBO_c \\sim \\Delta pCO_c $$ $$ \\displaystyle \\frac{AB}{oC} = \\frac{AO_c}{oO_c} = \\frac{PB}{p C} = \\frac{X_c}{x} = \\frac{Z_c}{f} = \\frac{Y_c}{y} $$ $$ x = f \\displaystyle \\frac{X_c}{Z_c}, y = f \\frac{Y_c}{Z_c} $$\n$$ Z_c \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}= \\lambda \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} f \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; f \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\\\ 1 \\end{bmatrix} $$\n其中，$f$ 是焦距，结合外参我们最终可以得到世界坐标系和像素坐标系之间的映射关系：\n$$ \\begin{array}{l} \\lambda \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} \u0026amp; = \\begin{bmatrix} \\displaystyle \\frac{1}{dx} \u0026amp; 0 \u0026amp; u_0 \\\\ 0 \u0026amp; \\displaystyle \\frac{1}{dy} \u0026amp; v_0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} f \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; f \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} \\mathbf{R} \u0026amp; \\mathbf{T} \\\\ 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\\\ 1 \\end{bmatrix}\\\\ \u0026amp; = \\begin{bmatrix} fx \u0026amp; 0 \u0026amp; u_0 \u0026amp; 0 \\\\ 0 \u0026amp; fy \u0026amp; v_0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} \\mathbf{R} \u0026amp; \\mathbf{T} \\\\ 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\\\ 1 \\end{bmatrix} \\end{array} $$ 其中，相机内参为（不考虑图像传感器的特性）： $$ \\begin{bmatrix} fx \u0026amp; 0 \u0026amp; u_0 \u0026amp; 0 \\\\ 0 \u0026amp; fy \u0026amp; v_0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} $$\n其中，$f_x, f_y$ 即为焦距的物理距离在像素坐标系中的长度，相机内参标定主要是标定相机的焦距、主点、歪斜等内部参数。\n可能存在的影响 主点偏移 主点是光轴和相机成像平面的交点，在理想情况下，图像坐标系和相机坐标系原点重合，不存在坐标系偏移。但在实际情况中，图像坐标系往往在图片的左上角，光轴过图像中心，因此图像坐标系和相机坐标系不重合。两个坐标系之间存在一个平移运动：\n考虑主点偏移后，图像坐标和3D在相机坐标系的关系为：\n$$ \\begin{matrix} u = f \\frac{X}{Z} + O_x \\\\ v = f \\frac{X}{Z} + O_y \\end{matrix} $$ 此时，透视投影模型（像素坐标系和相机坐标系）的关系为： $$ \\lambda \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} f \u0026amp; 0 \u0026amp; O_x \u0026amp; 0 \\\\ 0 \u0026amp; f \u0026amp; O_x \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\\\ 1 \\end{bmatrix} $$\n仔细观察就会发现，该关系与上面提到的关系是等价的，只不过上面使用坐标 $(u_0, v_0)$ 来代表偏移量 $(O_x, O_y)$。\n图像传感器特征 图像传感器像原尺寸在制造过程可能不是正方形，同时可能存在歪斜（skewed），因此需要考虑这些影响因素，传感器歪斜和不是正方形主要对相机 $x$ 和 $y$ 方向的焦距产生影响。\n此时，透视投影模型（像素坐标系和相机坐标系）的关系为： $$ \\lambda \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} f \u0026amp; s \u0026amp; O_x \u0026amp; 0 \\\\ 0 \u0026amp; \\eta f \u0026amp; O_x \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\\\ 1 \\end{bmatrix} = [K, 0_3] P $$ 其中，$K$ 矩阵即为最终的内参矩阵。\n镜头畸变 小孔成像模型虽然充分考虑了相机内部参数对成像的影响，但没有考虑成像系统另一个重要的部分，镜头。镜头常用的有普通镜头、广角镜头、鱼眼镜头等，在无人驾驶和视觉slam领域，鱼眼镜头和广角镜头用的很多，主要是视角很大，可以观测到更多的信息。任何镜头都存在不同程度的畸变，不同类型的镜头用到的畸变模型也不相同。\n在几何光学和阴极射线管（CRT）显示中，畸变（distortion）是对直线投影的一种偏移。简单来说直线投影是场景内的一条直线投影到图片上也保持为一条直线。那畸变简单来说就是一条直线投影到图片上不能保持为一条直线了，这是一种光学畸变。畸变一般可以分为两大类，包括径向畸变（radial distortion）和切向畸变（tangential distortion）。\n径向畸变来自于透镜形状，主要是由于透镜不同部位放大倍率不同造成的。切向畸变来自于整个相机的组装过程，主要是由于透镜安装与成像平面不平行造成的。\n径向畸变 透过镜头边缘的光线很容易产生径向畸变，这种现象来源于“筒形”或“鱼眼”的影响。光线离镜头中心越远，畸变越大。\n从图像可以看出，径向畸变以某一个中心往外延伸，且越往外，畸变越大；显然畸变与距离成一种非线性的变换关系，参考众多文献，可以用多项式来近似： $$ \\begin{matrix} x_{rcrt} = x(1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \\\\\\\\ y_{rcrt} = y(1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \\end{matrix} $$ 其中，$x, y$ 是归一化的图像坐标，即坐标原点已经移动到主点，并且像素坐标除以焦距。$k_1, k_2, k_3$ 是径向畸变系数，$r^2 = x^2 + y^2$。\n切向畸变 切向畸变主要发生在相机sensor和镜头不平行的情况下；因为有夹角，所以光透过镜头传到图像传感器上时，成像位置发生了变化。\n$$ \\begin{matrix} x_{tcrt} = x + [2p_1 xy + p_2 (r^2 + 2 x^2)] \\\\\\\\ y_{tcrt} = y + [2p_2 xy + p_1 (r^2 + 2 y^2)] \\end{matrix} $$ 其中，$x, y$ 是归一化的图像坐标，即坐标原点已经移动到主点，并且像素坐标除以焦距。$p_1, p_2$ 是切向畸变系数，$r^2 = x^2 + y^2$。\n消除镜头畸变 考虑镜头畸变前，我们可以将相机标定简单描述为以下过程：像素坐标 $(u_{ccd}, v_{ccd})$ $\\to$ 图像坐标 $(x, y)$ $\\to$ 相机坐标 $(X_c, Y_c, Z_c)$ $\\to$ 世界坐标 $(X_w, Y_w, Z_w)$。\n此时我们考虑加入镜头畸变： $$ \\begin{matrix} x_{crt} = x_{rcrt} + x_{tcrt} \\\\\\\\ y_{crt} = y_{rcrt} + y_{tcrt} \\end{matrix} $$ 得到消除镜头畸变的相机标定流程：像素坐标 $(u_{ccd - crt}, v_{ccd - crt})$ $\\to$ 图像坐标 $(x_{crt}, y_{crt})$ $\\to$ 相机坐标 $(X_c, Y_c, Z_c)$ $\\to$ 世界坐标 $(X_w, Y_w, Z_w)$。\n标定板的作用 相机标定中的参数 针孔相机模型中，只要确定这9个参数就可以唯一的确定针孔相机模型：\n$$ f_x,f_y,O_x,O_y,k_1,k_2,k_3,p_1,p_2 $$\n这个过程就称为「相机标定」，其中前4个我们称为内参数，后5个称为畸变参数，畸变参数是为了补充内参的。所以一旦相机结构固定，包括镜头结构固定，对焦距离固定，我们就可以用这9个的参数去近似这个相机。这里说的「镜头结构固定」，按我个人的理解，除了焦距固定之外，也应当包含光圈固定，因为改变光圈的大小，除了景深之外，是有可能改变针孔相机模型中的光心位置，但是影响并不是很大。这意味着标定好的相机如果改变光圈大小，会使得标定误差变大但应该不会大到难以接受的地步。\n对于针孔相机本身需要拟合的方程如下：\n$$ \\begin{bmatrix} u_{ccd - crt} * Z\\\\ v_{ccd - crt} * Z\\\\ Z \\end{bmatrix} = J(k_1, k_2, k_3, p_1, p_2) \\begin{bmatrix} f_x \u0026amp; 0 \u0026amp; O_x \\\\ 0 \u0026amp; f_y \u0026amp; O_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} X \\\\ Y \\\\ X \\end{bmatrix} $$\n因此，我们现在的任务就是找出一大堆具有对应关系的像点 ${(u_{ccd - crt}, v_{ccd - crt}) ^T }$ 和物点 ${ (X, Y, Z)^T }$ 的点作为样本，来训练出模型的参数。这里就引发了两个问题：\n这么多像点和物点如何匹配？ 即便现在知道物点的位置，如何用相机坐标系来表达物点的位置 $(X, Y, Z)$？ 为了解决上述问题，标定板应运而生。标定板的一大作用，确定物点和像点的对应性。这里用到的原理主要是「透视不变性」，打个比方，你近看一个人和远看一个人，虽然他的鼻子大小变了，你看鼻子的视角也变了，但是拓扑结构肯定是不变的，你也不可能把鼻子看成是嘴巴。\n所以在标定板中，印刷了拓扑结构，广泛应用的是棋盘格和圆点格，这两种之所以成为主流，不仅是因为它们的拓扑结构明确且均匀，更重要的是检测其拓扑结构的算法简单且有效。棋盘格检测的是角点，只要对拍摄到的棋盘格图像横纵两个方向计算梯度就可获得；而圆点格的检测只需要对拍摄到的圆点格图样计算质心即可。假如你开发了一套非常完美的检测人脸全部特征的算法，你完全可以用你的照片当作标定板。\n按照我的经验，圆点格的效果应该是好于棋盘格，因为圆点质心的「透视不变性」要比棋盘格的角点稳定的多。下图是同样尺寸、同样比例棋盘格和圆点在最大重投影误差处的误差对比，红色十字是提取的角点/质心，绿色圆圈是针孔相机模型计算出来认为的角点/质心位置。\n但是圆点格的检测似乎是Halcon的专利（存疑），因此OpenCV和Matlab标定工具箱用的是棋盘格，要用圆点格得要自己写算法。下文中提到的标定板说的都是棋盘格。\n标定板的第二大作用是把标定板中的角点变换到相机坐标系下的坐标 $(X, Y, Z)$。对于标定的初学者来说，很容易忽略的一点是标定板是具有标定板坐标系的。换句话说，标定板中的每个角点，在标定板坐标系下的位置是确定并且是已知的。\n而标定板坐标系变换到相机坐标系的变换矩阵，我们称它的元素为外参数。\n如何使用标定板 如果用OpenCV或Matlab标定工具箱进行标定，需要给出棋盘格的物理尺寸，这其实就是在建立标定板坐标系，从测量的角度讲，标定板的精度是相机标定精度的基准，是误差传递链上的第一个环节。所以为了使针孔相机模型更逼近真实相机，对标定板的质量有以下要求（按重要性顺序）：\n标定板的平面度高，棋盘格是直角。 标定板每个格子尺寸的高一致性。 真实尺寸与标称尺寸的差异小。 ","date":"2023-10-08T14:30:49Z","image":"https://3000ye.com/p/camera-calibration/board_hu_1abbded7927883aa.jpg","permalink":"https://3000ye.com/p/camera-calibration/","title":"Camera Calibration"},{"content":"Test page picture math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\ncode 1 2 3 4 5 6 7 8 9 #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } Test $\\LaTeX$ $\\frac{2}{3}$ ","date":"2023-10-08T14:30:49Z","image":"https://3000ye.com/p/test/nord_hu_5f562b3aed4cb5f8.jpg","permalink":"https://3000ye.com/p/test/","title":"Test"}]